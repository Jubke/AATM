While I'm not an Intel engineer, here's my guess: The behavior that you are seeing is the result of expensive state-switching. Here's the test code compiled on x64: Furthermore, I take no responsibility for whatever damage that may result from running this code. Back in the days, there were some characters that weren't always supported. An unknowing programmer would try to type in such a character only to find that it doesn't exist on the keyboard! Therefore, I would have expected it to wrap on overflow - despite the fact that it is undefined behavior. But that's clearly not the case. So what did I miss? No Pre-Faulting: http://coliru.stacked-crooked.com/a/1df1f3f9de420d18 As mentioned in the comments, there's a boost library that does this. But if you can't use boost, this should work: What you're trying to do is very difficult - to the point of being impractical for the following reasons: Getting a True Measurement of Time: The following code goes into an infinite loop on GCC: Warning: If you decide to compile and run this, pay attention to your CPU temperatures!!! Make sure you don't overheat it. And make sure CPU-throttling doesn't affect your results! Long Answer: In the manually inlined version, the "core" of one iteration looks like this: This can be done by touching all the arrays before the benchmark. http://www.agner.org/optimize/microarchitecture.pdf Output (8 threads, 10000000 iterations) - Compiled with Visual Studio 2010 SP1 - x64 Release: Here's where the 4 sums are recombined: The Intel compiler is trying to vectorize the loop. But the overhead added seems to outweigh the benefit of vectorizing it in the first place. Hence why it's slower. No. It just means that all local variables from the ambient scope are available for lookup inside the body of the lambda. Only if you refer to a name of an ambient local variable will that variable be captured, and it'll be captured by value. Does the standard have to say anything on this matter? After your update: The last paragraph is (in my opinion) the most striking explanation: In C++ you need to be able to write your own memory managing code (cf. "allocators"). And memory has to be handled via pointers. So my strict answer is that you need pointers in C++ when you're implementing the memory management, and never otherwise. Here's the example. Suppose I have a polymorphic hierarchy: I hope these two admittedly fairly contrived examples shed a bit of light on when you really want your shared pointers to be passed around by copy. In a well-designed program, it should always be clear who is responsible for which resources, and when used right, the shared pointer is a great tool for the job. About the only real use for pointers is direct memory manipulation. Since Java doesn't want you to do that (and in fact its garbage-collected memory management would actively interfere with and be broken by manual memory manipulation), there's no need for explicit pointers. I was discussing the merits of "modern" languages compared to C++ with some friends recently, when the following came up (I think inspired by Java): The simple answer is that it is a design decision. The slightly longer answer is that pointers in C++ are only necessary for memory manipulation, which is not a concept that applies to Java (see below). Note by the way that many things people attempt to do with pointers in C and C++ is actually undefined behaviour. Using pointers correctly leaves you with a fairly restricted set of options, most of which can be done better in idiomatic C++. When it comes to character handling in C, there are two groups of things related respectively to portability and serialization: Clarification: The main use case which I'm interested in is when the base class and the function with the loop (like the accumulator) are part of a separate translation unit or library, and there is no control over or knowledge of the derived classes. I was quite surprised when I saw the following code compile without errors or warnings in g++-4.2: I have not been able to identify where in the standard this is allowed, and I find it slightly confusing that two of the compilers warn that it is required, shouldn't it be an error if the typedef-name is required but not present? Question 2: If a constructor must be specified in a base class, then that class cannot be part of a union. Basic simplification of the article: Even in the few cases where the difference in performance of one approach from the other could be measurable (say that the functions only take two cycles, and that dispatch thus doubles the cost of each function) if this code is part of the 80% of the code that takes less than 20% of the cpu time, and say that this particular piece of code takes 1% of the cpu (which is a huge amount if you consider the premise that for performance to be noticeable the function itself must take just one or two cycles!) then you are talking about 30 seconds out of 1 hour program run. Checking the premise again, on a 2GHz cpu, 1% of the time means that the function would have to be called over 10 million times per second.