I would like to drop all of the self-observing KVO code as I am concerned about the various entry and exit points and when to add and remove observers appropriately. It seems too dirty. If the user taps the bomb, you'd cancel the moving animation and have the bomb fly harmlessly away. Your original completion block would still be executed, so you'd need to know if the animation had finished on its own, or been cancelled. Tags, subclasses, or view hierarchy navigation are too much work!. Do this in your action method: The following bright idea doesn't work as it creates an "Invalid pairing of layout attributes (left and width)": How can I hit the sweet spot between an easy-to-manage project in Xcode, a small distribution package, and a manageable first-run experience? I'm happy for the iPad to be sat there for half an hour or so when the app is first installed, but any longer than that is not going to work. Is there a better way than using a zip file for the resources? Note that this still has the appearance of a user constraint - but if I try to delete it, IB will automatically recreate the system constraint pinning to the bottom of the superview, getting us back to square one. For a table view controller in a storyboard: I have the number of items in the active playlist displayed as the badge on a tab bar item. The view controller that the tab bar item represents is listening for a specific notification which is fired when the contents of the active playlist are updated. -(void)didChangeValueForKey:(NSString *)key It's part of the general brokenness of unit testing in Swift projects. The unit testing module should have special access to the app modules, otherwise you have to add loads of access control baggage. I have a navigation-based application where it is possible for the user to hide the status bar. This is remembered in a defaults setting. I've experimented with distributing the app without the resources and having it download them, if required, on first run as a zip file. Unfortunately unzipping the resources takes an unsustainable amount of time. The outermost view of your view hierarchy has it's origin at 0,0 which corresponds to the top left of the screen in iOS. This menu, together with careful selection of elements, is central to happy editing of constraints in IB. In your case, choose the central item, the Pin menu. Choose Vertical Spacing - this will create a new constraint on vertical spacing between your two elements. Alternatively, select a single element and pin "Top space to superview" to pin to the top instead of the bottom. Here is the code which toggles the status bar. This is in my application delegate, which has the navigationcontroller and window set up as outlets as per the template application. The finished parameter will be NO when the animation was cancelled: typically, when you have interrupted the animation to start another one (e.g. you have begun a new animation, before the current one has ended, with the parameter to begin from the current state) or you have directly cancelled the animation. I have implemented this in what I feel is a clumsy way and would like to do it better. It does work at the moment but I'm not happy with it. If you want to have completely different content in your cells to that found on the storyboard then static cells probably aren't the right choice. You should use dynamic prototypes (note you can have multiple prototypes in the storyboard) with the traditional data source methods instead. As with the default initializer above, if you want a public structure type to be initializable with a memberwise initializer when used in another module, you must provide a public memberwise initializer yourself as part of the typeâ€™s definition. When including these directly in the project, via folder references (as the images are retrieved using a derived path) Xcode slows to a crawl (due to indexing and maintaining a project of that complexity) and installation on a test device takes forever. This can be mitigated by removing the images after the first build (so they are still on the device) but that's not ideal. Additionally, when they're in the project, the bundle size is huge and this causes problems with deployment (not only download times, but it seems to fail quite often when downloading from our internal Apperian app store, presumably due to the sheer size). Invoked to inform the receiver that the value of a given property has changed. If you use testflight, it automatically compares the devices in the profile with your registered testers. It seems, via NSLogging, that the problem lies in the frame of the UINavigationBar. So I have added the following code, which works and animates but I am not happy with! I don't feel this can be the "correct" way to do this. In most cases the extra code does nothing since the frame is already at (0,0), but in the one situation where it is incorrect, this gives the right result. I'm building an app which requires 1.8GB of resources. It's an enterprise app which will be installed in a controlled environment. The resources need to be on the device from the start as it will be used without network coverage.