There is an even more insightful thread here, which is about an analogous change to C, started off by the Guy done the above linked article. Among other useful facts, they present a solution that seems to also apply to C++0x (Update: This won't work anymore with n3225 - see below!) I accidentally put the opening brace of my function definition after the return statement (admittedly not really a compatibility problem for most people). I recently stumbles across some problem with initializer lists. Consider a program that stores map-like data Summary, paraphrasing the FDIS here, to make it (better) suitable as a SO answer. I added some examples of my own to illustrate the differences. I have this question, which i thought about earlier, but figured it's not trivial to answer Non-type Parameters What you have there is of the last kind. It's a compile time constant (so-called constant expression) and is of type integer or enumeration. After looking it up in the standard, i had to move class templates up into the types section - even though templates are not types. But they are called type-parameters for the purpose of describing those kinds nonetheless. You can have pointers (and also member pointers) and references to objects/functions that have external linkage (those that can be linked to from other object files and whose address is unique in the entire program). Examples: What compiler is right and is my code valid at all? Please refer to or quote the proper Standard section in your answer. Thanks! I have heard and read that C++0x allows an compiler to print "Hello" for the following snippet Unnamed namespaces are a utility to make an identifier effectively translation unit local. They behave as if you would choose an unique name per translation unit for a namespace: Update on 3.1.2011 with n3225: Committee moved the text to 1.10/24 and say Nope, there is none, unless you do the mapping yourself. C++ has no mechanism to create objects whose types are determined at runtime. You can use a map to do that mapping yourself, though: One work around is to declare an initializer-list constructor I use Intel C++ and GCC. Some of my buddies use clang, so I would be glad to hear solutions for that too. They are not null if you don't initialize the struct. Thanks to anyone who helped me understand GCC's behavior. I filed a new Clang bug report: For an example of a possible surprise, consider this one: Deduction therefore succeeds too, for every A / P pair. Now, each template is at least as specialized as the other, because deduction didn't also rely on any implicit conversions and succeeded in both directions. As a result, the call should be ambiguous. RAII This is a strange name for a simple but awesome concept. Better is the name Scope Bound Resource Management (SBRM). The idea is that often you happen to allocate resources at the begin of a block, and need to release it at the exit of a block. Exiting the block can happen by normal flow control, jumping out of it, and even by an exception. To cover all these cases, the code becomes more complicated and redundant.