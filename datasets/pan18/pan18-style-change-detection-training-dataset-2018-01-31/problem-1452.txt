Reset the app to its previous state. Save your storyboard/xib file after making a change, and be sure to rebuild the app. It's not hard to miss that step, and then you're left scratching your head wondering why your changes didn't seem to have any effect. After looking at your code, the reason that your curve is jagged is that you're thinking of control points as points on the curve. In a bezier curve, the control points are usually not on the curve. Since you're taking the control points from the curve, the control points and the point of intersection are not collinear, and the paths therefore don't join smoothly. The problem with the code that you posted is that you're counting on the view size to match that of the screen, and as you've seen that's not always the case. If you need the screen size, you should look at the object that represents the screen itself, like this: Have your app advertise that it can handle URL's with a given scheme. Here's output from the code above: Under iOS 8, however, the video is enlarged and shifted down; it looks like the content size is the same as the screen size, with the content's origin at the origin of my web view: So... it looks like VM Tracker is able to see some significant memory use that Allocations isn't. Use the "Wait for MyApp.app to launch" option. Apple used to require a 512 x 512 px icon for this purpose -- sounds like they've doubled the resolution to support retina displays. Before you jump into any of those, read Apple's Archives and Serializations Programming Guide, User Defaults Programming Topics, and File System Programming Guide. Contrary to popular mis-conception, ARC does not automatically de-stackify Blocks passed as arguments to methods. It only de-stackify's automatically when a block is returned from a method/function. In working with quite a bit of Objective-C++ code over the last 20+ years, a bridge like this is generally more trouble than it is worth. You would likely be better off -- spend less time writing and debugging code -- creating simple Objective-C wrappers around the C++ (or C, frankly) APIs that can then be integrated with and consumed by the targeted system's Objective-C frameworks. I.e. the compiler could generate: At least, I'm pretty sure that is what is going on. Two ways to know for sure; take the code for those two functions and compile it with -Os for x86_64 vs. ARM and see what the resulting instruction streams look like (i.e. both functions on each architecture) or wait until Greg Parker shows up to correct this answer. First, the memory is still reachable from the live object graph. Thus, by definition, there is an algorithmic problem in your application that is keeping the memory alive. Finding and fixing that can often be much more difficult and potentially disruptive then fixing a mere leak. The old project makes use of string constants in various places. The new code uses a massive enum for the same thing. (The new code in general uses more constants.) Alternatively (or in addition to iTunes), you could use the MessageUI framework and allow the user to email the file. It looks like the peaking is being caused by calls to the KosherCocoa library. If anyone would mind taking a look at it and telling me what I'm doing wrong there as far as memory management goes, I'd really appreciate it. I bet that a silent looping MP3 file would help work towards your goal. How do I take a search string and "use regex" to search hebrew text that contains vowels, ignoring those vowels? First, I realized that I was setting the border and the near-white color on the FilterBar itself, and the barTintColor was in a second layer. The near-white was bleeding into the border, so I added another layer for the white. To solve this problem, I manually created the color space I needed and then the transparent black color. On the device, it works perfectly, but on the simulator it's still a little off. Is there an easy way to do this? Any open source code? Do I need to have an API key to use the RESTful API? If so, how do I obtain one? I just got started with Core Data this week. Great question! I haven't worked out how to imitate this in my library that I'm developing, but this screenshot has given me something to work with. I also am not sure how to mimic the borders, but this should be a great starting point. The odd pattern in the beginning of the run. Allocations seems to peak at 1.47 megabytes, but running it overnight shows that it actually will slowly use more and more memory over time. That can't be a good thing. There are several notable differences between the old project and the new one.