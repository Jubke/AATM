Here it's definitely undefined behavior. Nowadays is almost always better to just use the standard library math functions, since these tiny things are hardly the cause of most bottlenecks anyway. But I still want to do a comparison, just for curiosity's sake. So I want to make sure when I profile, I'm not getting skewed results. As such, I'd like to make sure the compiler does not optimize out statements that have no side effect, such as: In C++03, the closest approximation was: I can understand the rationale behind either choice: [too much               space]  
[too much space]  
[too-much-space]  
[one  
two]  
 Though if you can Boost, I'd recommend it. It also follows that it's undefined behavior directly from (§9.3.1/1): Because if it's not by reference, it's by value. To do that you make a copy, and to do that you call the copy constructor. But to do that, we need to make a new value, so we call the copy constructor, and so on... I'm using Visual Studio 2008 / G++ (3.4.4). The first thing to understand is why it's undefined behavior to dereference a null pointer. In C++03, there's actually a bit of ambiguity here. In the standard, §2.1/1 specifies: If I debug the node, I get this output: Some abridged quotes for convenience: Regardless, it definitely cannot be converted to an rvalue (§4.1/1): With static functions, the strict versus weak interpretation makes the difference. Strictly speaking, it is undefined: Although "dereferencing a null pointer results in undefined behavior" is mentioned in notes in both §1.9/4 and §8.3.2/4, it's never explicitly stated. (Notes are non-normative.) In C++0x, as of n3126, the ambiguity remains. For now, be safe: use the strict interpretation. — otherwise, begin-expr and end-expr are begin(__range) and end(__range), respectively, where begin and end are looked up with argument-dependent lookup (3.4.2). For the purposes of this name lookup, namespace std is an associated namespace. So telling me "these tricks aren't useful anymore, stop trying to micro-optimize blah blah" is an answer completely missing the point. I know they aren't useful, I don't use them. As expected, both error cases don't match. But in the first case, my struct only captures the first character. I'd like to keep the struct for organization purposes. We all know that the old tricks aren't very useful anymore, I'm merely curious how not useful they are. Just plain curiosity. Sure, life could go on without me knowing just how these old hacks perform against modern day CPU's, but it never hurts to know. Which is wrong. This is mentioned in the for-each documentation. So we have a strict "dereference a null pointer, get undefined behavior" view and a weak "use a dereferenced null pointer, get undefined behavior" view. (You would have infinite recursion because "to make a copy, you need to make a copy".) When dereferencing, the result is an lvalue. A null pointer does not refer to an object, therefore when we use the lvalue we have undefined behavior. The problem is that the previous sentence is never stated, so what does it mean to "use" the lvalue? Just even generate it at all, or to use it in the more formal sense of perform lvalue-to-rvalue conversion? Edit Again To clarify once more, read this: I'm not trying to micro-optimize this in some sort of production code. Edit To clarify, I would like to have all optimizations maxed out, to get good profile results. The problem is that with this the statements with no side-effect will be optimized out, hence the situation. So, again, the treatment of source files is something you need to find in your compilers documentation. Are there any other better/simpler ways to accomplish this? Here's a SSCCE, configurable to debug: Problem The problem is generating the types I need, so I may eventually use Fusion to instantiate those types. The types in use are (shortened, etc.): However, one can try to deduced it from §3.10/2: Premature quoting of Knuth is the root of all annoyance. In response to your edit, I don't know the term but I'd guess something along the lines of "reduce", so that's what I called it. :) (Note, I've changed the white-space to be a parameter, for flexibility) Note that the C++ standard is based off the C standard (§1.1/2), and the C(99) standard says, in §1.2: Otherwise, you just have to copy each element: I was thinking of doing something like this: Your compiler doesn't support that format (aka cannot map it to the basic source character set), so it cannot move into further processing stages, hence the error. It is entirely possible that your compiler support a mapping from image to basic source character set, but is not required to. In the end, this means small objects globally have amortized constant time allocation and constant time deallocation. (Yay.) Since this mapping is implementation-defined, you'll need to look at your implementations documentation to see the file formats it supports. Typically, every major compiler vendor supports (canonically defined) text files: any file produced by a text editor, typically a series of characters. EDIT: I have seen a very slight increase in their usage since I posted this, however. I still avoid them. In there, it calls the function, and forwards the return value. What for? You need to clarify: Do you need a pointer to the first element of an array, or an array?