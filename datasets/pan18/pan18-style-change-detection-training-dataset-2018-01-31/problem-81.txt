The short answer is: Don't constrain tasks unless there is a real technical dependency, let them float freely until the point a task actually starts and then fix its start date and start logging "Work Completed" against it. Let MS-P resolve resource allocations using levelling, which will keep the end date realistic based on the work remaining in the project, and instead of using Percentage Complete, use Work, Work Completed and Work Remaining to manage effort on the tasks as the situation changes. That is to say, MS-Project works from the position that tasks require an intrinsic amount of work to complete, against which you allocate resources thereby subdividing the work amongst the resources. The converse model, as used by Project Managers Workbench (last time I used it), is that you have a bunch of resources who can do work, which you combine as required, with the work for the task being derived as the total of your resource allocations. They have subtly different consequences. 

If a task that was supposed to start in the past, did not actually start, then that workload (or some of the workload if it was only partially completed) still needs to be done. So the task, or the remaining part of the task needs to be moved into the future. 

But as far as I am aware a more generic solution does not exist because MS-Project doesn't work that way- You don't start with a bunch of resources spending known amounts of hours and work up to a task that is the sum total of the resource spend- MS-Project works the other way around. 

Know your requirements in clear, accurate and unambiguous detail - You must know what it is you are delivering else how will you know when you have achieved it. 

What you need to do is arrange the tasks and the resources in such a way that you are maximising parallel working- make it so that people are not tripping up over each other and artificially elongating their tasks. I have formulated and defined the following view over many years and now use it quite successfully when I am at an interview seeking a role, and of course in real life when managing projects. 

If all you're changing are task durations (i.e. no different tasks, changed predecessors, successors, etc), you could use the DurationX columns (Duration1, Duration2, etc) to represent the other durations. I found the best approach is to use small colored icons in a number column: blue/green/yellow/red. 

Paste the following into the Custom Attributes / Formula for any Number field (make sure it's all on one line): Under Tools | Customize | Customize Fields..., set the display to "Graphical Indicators." Set it to "Nonsummary rows" and add the following tests: 

Here's what it looks like in practice. Color coding: For example, I wrote a custom formula (see below) that sets the value of Number1 based on the current date and the Finish date of each task. Then, using that value, I set up the Graphical Indicators to show a blue dot for complete, yellow for in progress, green for future, and red for overdue. Unfortunately, it's a bit of setup, but once it is done, it updates automatically. No macro or coding needed. 

Optimistic, Standard, and Pessimistic Duration columns On an existing number column (e.g. Number1, etc), right-click and choose "Customize Fields" then select the individual field by name. Then, at the bottom of the form, click "Graphical Indicators" and set up ranges for each color icon, then choose the color icon itself. If there were anything that were "perfect" then project managers would be paid minimum wage. 

Both of those are returning "0" duration for tasks with known values for both fields. Our Program Management office is interested in identifying tasks where the projected execution differs from the planned execution. MS Project's "Duration Variance" field calculates the difference between the baseline duration and the planned duration Another example: For one class of reports, we use 50% to indicate that the report is complete and in peer review, and 90% to indicate that it has been submitted to the customer for review & edit. If it is a repetitive process, it may not be a project; it may be a process. (and if it has no start date, then I'm not sure what meaning "schedule" has.) I'd also look for patterns in the distribution... but I'm way beyond what OP asked at this point, I'm just thinking about how I'd use the data. I think that Mr. Espina has described using Critical Chain Management to address the problem of managing the risk of task slippage. When I have had a need for similar buffers, I've used two techniques. First is to manually insert a milestone after the task, and move the milestone to manage the slippage. The other is to use PERT Analysis. MS Project allows you to plan the schedule based on weighted estimates. That allows you to display an optimistic/pessimistic/most likely schedule. Not precisely what you're looking for, but the technique may help. An example: for many documentation tasks, we have a convention that when you start the task and set up the document, that is 10% done. When you have the first draft ready for coordination that is 30% done. When you submit to the customer for review & edit that is 60% done. When the customer accepts the document it is 100% done. A counterexample: When I'm sitting in a meeting and I hear a project specialist say something like, "OK, there has been some progress, so let's just advance this task by 5%...." I get sick to my stomach. At that point I have zero confidence in their schedule, their variance, their earned value management, their risk management, etc. They are managing the project by gut and rumor and concealing it with fancy % values.