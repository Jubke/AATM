I would like to begin experimenting with algorithms that recognize patterns in data. I deal with many types of sequences (image pixels, text input, user movement), and it would be fun to make use of Pattern Recognition to try to pull meaningful data out of different datasets. Like the majority of the web, my data is mostly text or integer-key based. This is a US phone formatter that works on more versions of numbers than any of the current answers. However, in the event that a gettext translation doesn't exist for the given key then there is no way to fall back to a default (like you could with a custom handler). This means that you either have the writter mucking around in your code - or have "error.404_not_found" shown to users that don't have a locale translation! How does the default PHP error handler work? Is it safe from race conditions? As far as I can tell, the only reason we have namespacing in PHP is to fix the problem of classes (+ functions & constants) clashing with others classes of the same name. Use a database table to store this information and then link it to the user's session. That way you don't lose the information and you can go back and build statistics based on users carts or solve problems with your checkout process. So how does namespacing help this any? Either the class is loaded based off of it's name: To clarify, if the app can't do multi-file code completion (complete code in one file, based on classes in other files) then it doesn't fit my requirements. Thanks to OIS for finally setting me strait on this issue. Neither No large sites would dare store a user's cart in a session or cookie - that data is just to valuable. There are plenty of small editors like Notepad++, vim, & SciTE - but they only work on one file at a time. In other words, they aren't aware of the whole scope of the codebase. See the following example which shows overloading. What @Travesty3 is saying is that you can have two cookies - one for the session, and another that is either a "keep me logged in" cookie (which exists longer than the session cookie), or a copy of the data inside separate cookie. What tiny open source projects have you found that should be shared so others can build faster applications? Answer with the most votes wins. But really, we will all win by discovering cool projects. As time goes on people are finding smaller, more efficient ways to do things. I'm really impressed at some of the amazing things people have made that are so incredibly simple. So at the end of your script PHP will auto-close the connection and you will lose the prepared statement only to have your script re-created it on the next load. http://www.webdesignforums.net/showthread.php?t=18762 It's a win-win. Then later on you can use their API's to pull the comments and put them in your database if you want to switch to a home-made solution. $is-filename allows some additional characters like temp vim files If you really want an easy to use solution, then just download the intensedebate or Disqus comment HTML and you can leave spam checking, OpenID support, Comment sharing, and every other cool feature to them. You get the comments with no work! This is more complex than using PHP files with arrays of strings - but that method is incredibly inefficient when you have 2,000 translation lines. Is there anything wrong with this approach? It seems that even if persistent connections are the solution - they are not a very good option for most of the web - especially if you use transactions. So I'm back to square one having nothing more than the benchmarks below to go on... Are their any classes that give the basic framework for checking/creating patterns for PHP or Nodejs? update: removed the star character since I could not think of a valid use You can build an events system as simple or complex as you want it. This will always work. (If the PHP version is 4.2.0 or higher) I want to insure that there are no race conditions introduced by using a custom PHP error handler. To that end I want to know if I can rely on error_log() or if I need to use some other file-locking method to insure errors are logged correctly.