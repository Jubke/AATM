I don't understand the problem! See @IronMensan 's answer for the purpose of such a macro! One alternative i thought of: If several Integral objects can share the same MathFunction via a pointer to the same address, I could create copies of Integral objects without the need to copy the MathFunction. But in this case I would have to make all the properties const or somehow readonly, which is not very elegant either. Also, which Integral object should handle delete the MathFunction object? It's undocumented except for this video by Lavavej http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Stephan-T-Lavavej-Advanced-STL-3-of-n If you are using Microsoft Visual C++ there is one compiler option that tells you, how large your object actually is: /d1reportSingleClassLayout It there a predefined c++ compiler macro that I can use to tell, whether a file is compiled with "Use Precompiled Headers", "Create Precompiled Headers", "Dont Use Precompiled Headers"? b.cpp:16:12: error: explicit specialization in non-namespace scope ‘struct A::B’ Are you seriously saying, that as soon as you work with polymorphic objects you don't ever need a copy operation? What makes polymorphic object different from other objects in this respect? If I want to clone a polymorphic object in C++ (i.e. an instance of a class A which is derived from some other class B), the easiest way seems to give B a virtual clone member function, that has to be overridden by A and looks like this So I am also automatically friends with all my clones :-) as they are just other instances of myself. boost::weak_ptr<T> Used with shared_ptr<T>. In situations where a cycle of pointers may happen. How do you find valid locale names? Lets keep 1 type of semantic ownership per answer so they can be voted up and down individually What is the current support for tr1 or the new C++0x on the Mac Currently (after a quck search) the simplist algorithm is: Summary: Conceptually smart pointers are simple and a naive implementations are easy. I have seen many attempted implementations, but invariably they are broken in some way that is not obvious to casual use and examples. Thus I recommend always using well tested "Smart Pointers" from a library rather than rolling your own. std::auto_ptr or one of the boost smart pointers seem to cover all my needs. Though our children can not directly accesses the wireless they can get access to it if they go through us. So John's children can access my wireless if they access it via John (ie they are supervised and protected by John). These operators should return a bool as they are comparing two objects of the same type. It is usually easiest to define these operators as part of the class. This is because a class is automatically a friend of itself so objects of type Paragraph can examine each other (even each others private members). Also, friendship is not symmetric. John has a goverment job so he unfortunately is not allowed to trust anyone, especially when it comes to wireless. boost::shared_ptr<T> (std::tr1::shared_ptr<T>) Multiple ownership. This is a simple reference counted pointer. When reference count reaches zero object is destroyed. Anything dangerous (i.e. that could throw an exception) should be done via public methods (not necessarily directly). The user of your class can then potentially handle these situations by using the public methods and catching any potential exceptions. Usually I would advise against starting out thinking "this needs to be as fast as possible". Requirements should be achievable, and by definition "as X as possible" is only borderline achievable. Requirements should also be testable, and "as X as possible" isn't testable unless you somehow know a theoretical maximum. A more friendly requirement is "this needs to process video frames of such-and-such resolution in real time on such-and-such a speed CPU", or "this needs to be faster than our main competitor's product". If the C# version does that, with a bit to spare to account for unexpected minor issues in the user's setup, then job done. To improve build times. To link against code without having the source for the definitions. To avoid marking everything "inline". If your more general question is, "why isn't C++ identical to Java?", then I have to ask, "why are you writing C++ instead of Java?" ;-p Since they say "timing", I guess it's because they want their init functions to be able to call virtual functions on the object. This doesn't always work in a constructor, because in the constructor of the base class, the derived class part of the object "doesn't exist yet", and in particular you can't access virtual functions defined in the derived class. Instead, the base class version of the function is called, if defined. If it's not defined, (implying that the function is pure virtual), you get undefined behavior.