Is there a way to create a single function that combines both of these? Note that you can concatenate string literals by placing them next to each other; for example, the following two are equivalent: There are lots of subtleties with these new language features, but if you follow one simple rule, it's pretty easy: I've played a bit with the template arguments but haven't come up with anything; it'd just be nice not to have to call one function for enumerated types and another for everything else. I have the following function that will convert a string into a numeric data type: Per C++11 ยง5.1.2[expr.prim.lambda]/11: You can get a pointer to the first element as follows: Assuming the container has at least one element in it, you need to get the address of the initial element of the container, which you can get via In your example, we make the call: Let the compiler do the hard work, and 99.9% of the time it'll be exactly what you wanted anyway. When it isn't what you wanted, you'll usually get a compilation error which is easy to identify and fix. We're programming on a proprietary embedded platform sitting atop of VxWorks 5.5. In our toolbox, we have a condition variable, that is implemented using a VxWorks binary semaphore. The question How would you go about implementing this composite traits making use of what's already there? ========================================================================
exc:
Throw location unknown (consider using BOOST_THROW_EXCEPTION)
Dynamic exception type: some_exception
[tag_test_int*] = 42
========================================================================
*this:
Throw location unknown (consider using BOOST_THROW_EXCEPTION)
Dynamic exception type: exception_impl
std::exception::what: "blah"
 IIRC, exception objects have to be copyable according to the standard and, disregarding possible optimizations, the result of a throw expression is copied. So boost's exceptions must be copyable and they certainly do not lose their information along the way. I must be missing something fairly obvious here. What mess this leads to Your co-workers like this shiny new tool and also start to employ it, and pretty soon someone collects in a header what you all have come up with so far. Here's ours: Assignment, at its heart, is two steps: tearing down the object's old state and building its new state as a copy of some other object's state. In C++, this is often done using function objects (also called functors). These are objects that overload the function call operator, so you can call them as if they were a function. Example: From [dcl.fct], pretty explicitly: Just to update this question for C++11, this is now both possible to do and very natural: The following program compiles with both gcc and clang, but is this actually standard C++11 or do both compilers choose to support it for convenience? This example consists of multiple files: The last bullet point there gives us a difference. Consider: Instead, you can either fold over a comma: Yes, there is such a case where the two will not behave the same. At the time the C++ standard didn't have a special term for this, which was an oversight in C++11 and makes it hard to teach. This oversight was remedied by N4164, which added the following definition to [temp.deduct]: I want to write some function that takes a string literal - and only a string literal: Unless both pointers point to elements of the same array object, or one past the last element of the array object, the behavior is undefined.