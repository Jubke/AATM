Scott Myers has an excellent article about the subject in his book "Effective C++" Does their usage exactly overlap (so I can do a global find/replace on my code (not that I would do this, but if I did)) or should I be aware of some differences that are not apparent from reading the documentation? Which with manual editing resolved too: To my surprise the following code compiles: So in affect you pass the responsibility onto the user. If the user is in a position to correct exceptions they will manually call the appropriate functions and processes any errors. If the user of the object is not worried (as the object will be destroyed) then the destructor is left to take care of business. So if the user of a file object wants to do special handling for problems associated to closing the file they will manually call close() and handle any exceptions. If on the other hand they do not care then the destructor will be left to handle the situation. Question: My problem boils to getting the start address of win32 thread from another application (written in C#), as once I get it, I will get the name as well, using the above mentioned APIs. So how to get the start address? I want to return array of folllowing types from a function: Compiler and Platform I'm using GCC 4.9 on RHEL5. Now, in the C# code, I want to get the name/symbol of the start address of each thread created in the Win32 application so that I could log thread related information, such as CPU usage, to database. Basically, C# code starts multiple instances of the Win32 Application, monitors them, kills if needed, and then logs info/error/exceptions/reason/etc to database. I'm using Dell's laptop : Windows 7 Basic 64-bit. I've already installed MinGW version 4.5.0. I've also installed Visual Studio 2008 as well as 2010. Here is my p/invoke declarations: (Note that paths has been edited for brevity, using dollar-sign and dummy paths.) What do you think is the best choice for me? Which Clang should I download? How should I configure it? I'm going to use Clang for the first time. So suggest me the best options! According to C++, it is because no sub-object may have a zero size. However a base is authorized to have a zero size (EBO) therefore: Use the Clang library to get an AST (abstract syntax tree) Perform a mark-and-sweep analysis from the entry points onward Because Clang will parse the code for you, and perform overload resolution, you won't have to deal with the C++ languages rules, and you'll be able to concentrate on the problem at hand. And therefore I am looking for: It seems difficult though to get that binding + the array transformation in one step. Especially because arrays of references (and pointer to references) are not allowed in the language. You should probably read up Alexandrescu's book. At the moment, I am simply thinking of renaming the files, that should cover the issue... Therefore, it's impossible at compilation time to be able to deduce the necessary pointer arithmetic: it depends on the runtime type of the object.