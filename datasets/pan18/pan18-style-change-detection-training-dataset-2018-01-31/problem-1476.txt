But in order to keep my watch running, I need to handle the error instead of letting it pass, something like When you have two scrollable panels, one (a kind of dialog) being over the other one, how do you make the front panel scrollable using the mouse wheel while fixing the one behind ? The copy to clipboard would be initiated by javascript but having user confirmation or a dialog isn't a problem. Is there a solution to change it to something simpler in this style : I need a function building a JSON valid string from any argument but : *Note : sometimes, on Chrome/linux (not Chromium) I get something weirder : existing logs are changed when closing and reopening the console. They can go from the array like form to the folded form. * I have a directory where some other programs write XML files that I have to process when they're complete. Give a class "someClass" to all the involved buttons I dont' want a solution based on the integration of yet another copy or extract of the Olson tables (which I would have to maintain), I know there are a few libraries duplicating them, I want to use the ones I already have in Moment.js. It's a feature. But a very dangerous one. The best way to keep it being a feature for you is to stick to consistent formatting style (I'd suggest to use the Google style guide until you're experienced enough to make your own). My web application uses the Notification API. I'm querying some MDB files in nodejs on linux using MDBTools, unixodbc and the node odbc package. If you really need to deal with such numbers, you have to represent them in another way. This could be a string, or a specific representation like a digit array. Some "big numbers" libraries are available in JavaScript. Is there today with HTML5 a way to copy to clipboard, without browser plugins (and so without Flash nor java) nor short-term hacks, an image built in a canvas ? This one is clear enough (just specifying types of arguments and return value): When a script tag is inserted dynamically, how the execution order behaves will depend upon the browser. You can see how Firefox behaves in this reference article. In a nutshell, the newer versions of Firefox default a dynamically added script tag to async unless the script tag has been set otherwise. Here are times when event delegation is required or advantageous: Here's what my code looks like now and I'm looking for a more elegant way to do this that doesn't require the ObjectWantsKeys function which is somewhat brittle: Take a simple function like this: When precaching as above, the images are loaded asynchronously so they will not block the loading or display of your page. But, if your page has lots of images of its own, these precache images can compete for bandwidth or connections with the images that are displayed in your page. Normally, this isn't a noticeable issue, but on a slow connection, this precaching could slow down the loading of the main page. If it was OK for preload images to be loaded last, then you could use a version of the function that would wait to start the preloading until after all other page resources were already loaded. In the socket.io documentation, they use a nomenclature that doesn't look like javascript (though it's a javascript library) that seems a bit out of place. If you wanted to really make it more work to view the source, you would do all of the following: In an ES6 environment, it is possible to use destructuring to create default properties/values for the above passed object. This is discussed in more detail in this reference article. I'm stumped. I assume this must be something silly I'm doing wrong in my use of promises, but I can't for the life of me see what's wrong. Bonus points if one can actually tell not only if scrollbars would generally be required, but whether they are actually there or not. tags, then the javascript code won't be immediately visible with the View Source command - only the script tag itself will be visible that way. That doesn't mean that someone can't just load that external javascript file to see it, but you did ask how to keep it out of the browser's View Source command and this will do it. When you have problems, it's also quite a pain to debug because it's like the Heisenberg uncertainty principle. As soon as you set a breakpoint anywhere in the sequence, everything changes. You have to put all sorts of debugging statements in the code to try to discern what's happening. So, the clearing of a variable only needs to be done when you explicitly want to free data that is held in a long lasting variable and it's usually only relevant to worry about this when the data is large or you have a lot of them that add up to multiple megabytes of data (memory use is of higher concern at lower levels on smartphones than in desktop browsers).