Given the following XML chunk: So how would that work? The plugin needs to be created somewhere, so this needs a factory. The factory build method knows what your plugin needs: The data URI you have in your example is not a valid PNG image. This will never work and is unrelated to the code, it's related to the data. I think these are enough examples for one answer. You can find the full source-code as well as an example to display nice-looking ascii-trees in this gist: https://gist.github.com/3599532 It extends from the PHPUnit_TestCase. Where in the PHP manual is it stated that static function variables are initialized to NULL and considered empty? Is that version number/string unambiguous for now and in the future? Whatever I try, I have problems to describe the overruling nature of an ancestor with the matching predicate over an ancestor with a non-matching predicate. Let's review with some real-life examples that are not that abstract. Between interfaces, concrete iterators, container objects and iteration semantics this maybe is not a that bad idea. Eastern Daylight Time (EDT), when observing daylight saving time (spring/summer) is 4 hours behind Coordinated Universal Time (UTC−04:00). I'd like to merge two arrays with each other: Step 1: Kicking off We established that there needs to be at least one type that collects information about the query plan. Let's assume the type looks like this: PHP has no facility that enables a method to be "automatically" called, so there has to be something that triggers the materialization, even if that something does not look like a method call at first sight. But what? Well, think about what is perhaps the most common use case: Finally, here is an example that uses all the features: it first sorts by number descending, then by birthday ascending: TL;DR: Theoretically you can't count on it; for practical purposes IMO you can. For reference, I did google many obvious variations on "php logging stream filter". Running the timing test on my dev server to see it in action, I got: That's because theoretically the developers could have chosen to reserve themselves the option of changing the implementation at a future date so that it does not honor the existing order any more (perhaps to improve performance, or to gain some other benefit). To sort by number descending and then by name descending: Reverse sort To sort by name descending: You can also connect to your server via SSH and execute the following command: Let's review with some real-life examples that are not that abstract. Between interfaces, concrete iterators, container objects and iteration semantics this maybe is not a that bad idea. Right now PHP complains about an array to string conversion using the common setup: Is that version number/string unambiguous for now and in the future? Update: I've added more examples to show some of the edge cases. Lets see a first code example before writing any other sentence with the I-word: I wonder if and how it is possible to register a PHP userspace function with the XSLT processor that is able not only to take an array of nodes but also to return it? Eastern Daylight Time (EDT), when observing daylight saving time (spring/summer) is 4 hours behind Coordinated Universal Time (UTC−04:00). So how would that work? The plugin needs to be created somewhere, so this needs a factory. The factory build method knows what your plugin needs: Take a directory listing as an example. Consider you have got the following file and directory tree on disk: Where in the PHP manual is it stated that static function variables are initialized to NULL and considered empty? I don't understand why if the function gets an array as input is not able to return an array as well? Does not apply but might be of interest: I might run into a bug here when I see the output across multiple PHP versions, looks like that HHVM does not have this issue by transposing it: It extends from the PHPUnit_TestCase. If your plugin needs the dictionary object, it has to ask for it: Update: To clarify, what I 'm looking for is something that would allow me to write code morally equivalent to this: Let's sort the example data set without a projection and see what happens: Following this practice religiously will "automatically" take care of other things for you as well: TL;DR: Theoretically you can't count on it; for practical purposes IMO you can. Step 3: Materializing We still need some way to say "OK, I 'm done composing; get me the results". It is perfectly possible to use a dedicated method for this purpose: The algorithm below can be proved to work (barring bugs) by induction: That's because theoretically the developers could have chosen to reserve themselves the option of changing the implementation at a future date so that it does not honor the existing order any more (perhaps to improve performance, or to gain some other benefit). Reverse sort To sort by name descending: PHP has no facility that enables a method to be "automatically" called, so there has to be something that triggers the materialization, even if that something does not look like a method call at first sight. But what? Well, think about what is perhaps the most common use case: For reference, I did google many obvious variations on "php logging stream filter". That said, I should also mention that it's better to not use projections if your data set is large: in that case it would be much faster to project all your data manually up front and then sort without using a projection, although doing so will trade increased memory usage for faster sort speed. Finally, here is an example that uses all the features: it first sorts by number descending, then by birthday ascending: The key can also be a number if the items are numerically indexed arrays. For the example in the question, this would be Specifically, advantages of this solution include: The most practical approach is simply to cast the object you are interested in back into an array, which will allow you to access the properties: