Good news! Apple has fixed this bug as of iOS 7.0.3 (released today, Oct 22 2013). 

In the application I'm currently working on, there's a case where I have 2 screens for a set of data: one is a list and one is a map. Each screen has its own view controller. The default screen is the list view, so that view controller loads first. But the other map screen view controller is also loaded and set up (as it encapsulates some geographic map-related data that the list screen view controller uses), even though the map screen is not visible yet. I filed this issue back on Oct 21 2013 as Radar #15283329. Please do file duplicate bug reports so that Apple prioritizes a fix. 

Check out the open source library PureLayout. It offers a few API methods for distributing views, including variants where the spacing between each view is fixed (view size varies as needed), and where the size of each view is fixed (spacing between views varies as needed). Note that all of these are accomplished without the use of any "spacer views". 

Apple's documentation on creating Auto Layout constraints between a view and one of the layout guides only shows an example using VFL. 

I spoke with an Apple UIKit engineer today at the iOS 7 Tech Talks event in SF, and confirmed that this is an open bug that will be fixed "soon" by Apple. 

Any ideas what the controller name is for that view (so I can apply the same exclusion as above), or another way to fix this? 

This issue seems to come up more frequently when you have changed the content compression resistance or content hugging priorities for views, so try commenting out any code that does that to see if it's causing this bug to happen, or re-ordering it to happen earlier or later in your constraint setup code. More details about my specific case: This was the problematic code: 

Here are the remaining issues that have not been fixed yet: 

Xcode 6 Interface Builder introduced a new option to have this property set to Automatic. Unfortunately, there are some serious bugs (as of Xcode 6.2/iOS 8.2) where this is not set correctly/automatically when loading a cell from a nib or Storyboard. If you're using Auto Layout, here's what you need to do: Next, we make sure that the contentView of the cell has the same size as we just assigned to the cell itself, by setting the contentView's bounds to equal the cell's bounds. This is necessary because all of the auto layout constraints you have created are relative to the contentView, so the contentView must be the correct size in order for them to get solved correctly. Just setting the cell's size manually does not automatically size the contentView to match. 

I also cannot reproduce the issue under iOS 7.0.3 on one of the other apps I am developing, where the bug was causing problems. I'm not sure what your view controller transition looks like, but you could try removing the disappearing view controller's view from its superview before doing the present. That should prevent it from doing layout calculations as it transitions. If that solves the performance issue, you could quickly snapshot the view hierarchy and then replace it with a single new UIImageView of the snapshot to display during the transition animation. However, this little hack doesn't work when you tap the Groups button from the initial view. It still looks broken due to the extra tall Navigation Bar: 

(My assumption is that the app is killed and completely removed from memory, given that the app's executable code has likely changed during the update.) Are you by any chance removing and re-adding constraints anywhere at runtime? I've seen this exact problem caused by that (can explain more if this is relevant). 

Changing the order that you add (activate) constraints can end up changing the order of calculations in the internal engine, which as a result can cause this issue to disappear as the math is done without any problematic loss of precision. Here are the two most probable causes: Make sure that the edges of each label are connected rigidly (with Required priority constraints) to the edges of each other and their superview. You want to make sure that if you imagine one of the labels growing in size, this would force the other labels to make room for it and most importantly force the superview to expand as well. I ran into this crash on iOS. The steps to reproduce it were quite interesting: When using a large estimated row height, scrolling to the last row with animation causes the table view cells to disappear. When using a small estimated row height, scrolling to the last row with animation causes the table view to finish scrolling too early, leaving some cells below the visible area (and the last row still offscreen). A new bug report (rdar://21539211) has been filed for these issues relating to scrolling with animation.