First, you can set up a shell alias: There's something wrong with your Python installation. No, there is not. But there is an easy workaround: child processes. But does it really matter? Check this out, with 3.3.0 64-bit again: There are two problems with this: Often, when C modules crash, it's because you're doing something which is invalid, or at least uncommon and untested. But whether it's your "fault" in that sense or not doesn't matter. The module should raise a Python exception that you can debug, instead of crashing. So, you should probably report a bug to whoever wrote the extension. But meanwhile, rather than waiting 6 months for the bug to be fixed and a new version to come out, you need to figure out what you did that triggered the crash, and whether there's some different way to do what you want. Or switch to a different library. What you missed here is timezones. * Warning: Do not give Notorious B.I.G. a hot dog. Gangsta rap zombies should never be fed after midnight. Or, if you had an aware datetime object, you need to either use a local (aware) epoch on both sides, or explicitly convert to and from UTC. But the effect is similar: you just yield from one, then yield from another. ** Not a huge one, and there's nothing you can do about it short of using Python 3.3 or completely restructuring your code. It's exactly the same case as translating list comprehensions to Python 1.5 loops, or any other case when there's a new optimization in version X.Y and you need to use an older version. So, you will need to service that pipe, writing to the screen and to the file. In general, getting the details right for this is very tricky.** In your case, there's only one pipe, and you're planning on servicing it synchronously, so it's not that bad. If you're not sure whether your code is CPU-bound or IO-bound, just try it both ways. You've discovered a bug in Python that you should report. First, in Python, if your code is CPU-bound, multithreading won't help, because only one thread can hold the Global Interpreter Lock, and therefore run Python code, at a time. So, you need to use processes, not threads. * See the comments for exceptions. Yes. In fact, there are two different ways to do it. You can work around this in three ways: If you're actually getting this error from running Python, this means the Python interpreter has crashed. There are only a few reasons this can happen: Putting it all together, here's how I'd write your program: Alternatively, you can have two executors in the same program with no problem. This has a performance costâ€”if you're using both executors at the same time, you'll end up trying to run (for example) 16 busy threads on 8 cores, which means there's going to be some context switching. But sometimes it's worth doing because, say, the two executors are rarely busy at the same time, and it makes your code a lot simpler. Or maybe one executor is running very large tasks that can take a while to complete, and the other is running very small tasks that need to complete as quickly as possible, because responsiveness is more important than throughput for part of your program. Your problem is that you didn't set the environment variable. If they might have newlines, or non-printable characters, etc., you can use escaping or quoting. Python has a variety of different kinds of escaping built into the stdlib.