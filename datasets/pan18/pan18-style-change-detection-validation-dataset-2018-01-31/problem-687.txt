I am extending an existing logging library. It is a system with two sides: The frontend is where tasks write their log messages into, the backend is where an application can plug listeners into which forward those messages to different sinks. The backend used to be one hard-wired listener, I am now extending this for flexibility. The code is to be used exclusively on embedded devices, where high performance (measured in number of bytes forwarded per millisecond) is a very important design and implementation objective. Consider the following code employing boost's exception class: Now, POSIX provides a wait function that also takes a mutex. This will unlock the mutex (so that some other task might write to the data) and waits for the other task to signal (it is done writing the data). I believe this implements what's called a Monitor, ICBWT. Have you included all of the following headers? We need such a wait function, but implementing it is tricky. A simple approach would do this: Efficiency has little (or nothing, really) to do with it. We are considering to do this on a single platform (GCC for Debian 8 on a Beaglebone) with both C and C++ code compiled by the same GCC version (as C99 and C++11, respectively). General comments are welcome as well, though. the list's string is ideally created at compile-time, or, if there's no way to do that, once at runtime, and I only need to copy around a pointer to a C string, since, according to #1, the strings are fixed in memory. This compiles with C++03, which we're stuck with right now. How can I do this? I think I have a pretty good idea about the pros and cons of both ideas, but would hope some of you could provide additional insides and maybe even more ideas. A question on comp.lang.c++.moderated didn't bring any answers either. P.S.: This is strictly C++03 + TR1 + Boost 1.52, no C++11/14 available. Once the run-time system figured out it would need to call a templatized virtual function, compilation is all done and the compiler cannot generate the appropriate instance anymore. Therefore you cannot have virtual member function templates. We are stuck on a rather old embedded platform (proprietary variant of VxWorks 5.5), with a rather old compiler (GCC 4.1.2), and boost 1.52 â€“ except for most of boost's parts relying on POSIX, because POSIX isn't fully implemented on that platform. The locking primitives available basically are several kind of semaphores (binary, counting etc.), on top of which we have already created mutexes, conditions variables, and monitors. I have a bunch of types that have a name. (They have more features, but for the sake of this discussion only the name is relevant.) These types and their names are setup at compile-time using a macro: