(Note that this kind of thing can be specific to a particular chip model number or even version. The results of your benchmarks could be different on other systems.) Throwing exceptions in a constructor is not bad practice. In fact, it is the only reasonable way for a constructor to indicate that there is a problem; e.g. that the parameters are invalid. Peter Lawrey's benchmarking indicates that thread creation is significantly faster these days in absolute terms, but it is unclear how much of this is due improvements in Java and/or the OS ... or faster processor speeds. But his numbers still indicate a 150+ fold improvement if you use a thread pool versus creating/starting a new thread each time. (And he makes the point that this is all relative ...) Has anyone researched the runtime costs involved in creating and garbage collecting Java WeakReference objects? Are there any performance issues (e.g. contention) for multi-threaded applications? the RHS of an assignment expression is completely evaluated (including any increments, decrements and/or other side-effects) before the value is assigned to the LHS. Failing that, does anyone know of a JSON library with a parser and a generator that can be configured to output "pretty" JSON with the attributes in (say) lexical order? (A Java or Ruby library would be ideal, but other leads are also welcome.) In case it is not already obvious: "You need to install the Java SDK (e.g. from Oracle's download site), and you should install it to a pathname without spaces, such as c:\j2se1.6."' NB: JAVA_HOME should NOT end with "\bin"1. It is also expensive in the sense that the thread ties down resources as long as it is alive; e.g. the thread stack, any objects reachable from the stack, the JVM thread descriptors, the OS native thread descriptors. All these things are platform specific, but they are not cheap on any Java platform I've ever come across. The problems are to do with your paths. Does anyone know of an existing open source tool that will perform this task? Also note that you could run into problems if you have ignored this advice in the Maven on Windows instructions about spaces in key pathnames. If you project the curves beyond 0.9 on the X-axis, it looks like 1) they will meet at about 1.0 and 2) the meeting point will be at roughly the same Y value as for X = 0.0. If the project strategy is to use Lombok, then the possible helpers will need to get used to it. The multiply is likely to be faster than the second conditional branch if the hardware-level branch prediction is ineffective. As you increase the ratio ... the branch prediction is becoming less effective. You create and use byte array I/O streams as follows: That's not on! If the agreed project strategy is to use Lombok, then commiters who gratuitously de-Lombok the code should be chastised, and if necessary have their commit rights withdrawn. Before you use Project Lombok (or any other game-changing technology) in some project (open source or other wise), you need to make sure that the project stake holders agree to this. This includes the developers, and any important users (e.g. formal or informal sponsors). Thus, even though it might not be essential that new Java thread stacks are zeroed (per the JVM spec), in practice (at least with OpenJDK 6 on Linux) they are zeroed. Java classes are executed within a larger context (a particular JVM as others have noted). Below are some possibilities: The compiler needs the right classpath in order to compile calls to a library (compile time dependencies) edit: here's a shot at it. I tried running it in C++ and Java for N=100000; they both match. Apologies if I used bad Java idioms, I'm still fairly new to Java. The java tool launches a Java application. It does this by starting a Java runtime environment, loading a specified class, and invoking that class's main method. The method declaration must look like the following: This “is<PropertyName>” method may be provided instead of a “get<PropertyName>” method, or it may be provided in addition to a “get<PropertyName>” method. In either case, if the “is<PropertyName>” method is present for a boolean property then we will use the “is<PropertyName>” method to read the property value. An example boolean property might be: 1) if your class C1 calls library class L1, and L1 calls library class L2, then C1 has a runtime dependency on L1 and L2, but only a compile time dependency on L1. From the javadoc for StringTokenizer: You should be able to verify this by running the algorithms in C++ and Java to compare the outputs. The logging doesn't necessarily have to be XML, but I do want it to be structured and machine-readable. Is there a nicer way to write in jUnit I know there is no direct equivalent in Java itself, but perhaps a third party? Edit - as of Apache Commons 2.1, the correct way to do it is: For me, the above steps solved the issue. Heh, I discovered/remembered what we are already using for this. I ended up rolling my own (I took the implementation of Throwable.printStackTrace() and tweaked it a bit): I just found CompletionService in this blog post. However, this does't really showcases the advantages of CompletionService over a standard ExecutorService. The same code can be written with either. So, when is a CompletionService useful? Why am I getting an error "Attribute value must be constant". Isn't null constant??? It is in fact a bug in hibernate, because it is thrown when persisting objects, while it actually implies a "design time" problem that should be detected when creating the schema. It is really convenient. Currently I'd like to implement an iterator that yields all nodes in a tree, which is about five lines of code with yield. As far as I've been able to tell, the error is caused by any combination of: Is there a jUnit parallel to NUnit's CollectionAssert? Executor seems like a clean abstraction. When would you want to use Thread directly rather than rely on the more robust executor?