So I let Xcode fix the warning for me, and it gave me this: 

This is the fun part. In Xcode, you need to add a key to your app's Info.plist file. Here's what that is going to look like in Xcode 4: 

After clicking on that link, you will be able to select which stores your app is for sale in. 

The simulator does not exist for Linux. 

I've messed with my original code and I found a simple solution. I've added the following check, for iOS 5 in my animation code: 

Create Object B Delete Object B Object B is gone, since it was never saved, there is no "marking for deletion". It's simply gone. 

Both classes use a factory class to create the slides. In the old project, the factory class was a singleton. I thought that making it into a normal class would help with the memory issues, since the singleton was never released. (Hence it's properties were not being released.In the new project, the factory class is being released so I'm not sure why it's still taking up all that memory (if that's what's causing the problem. 

To save in the App's documents directory, you'll need to do a few things. First of all, you'll need to get the URL to the path directory. A method for this is conveniently generated by Xcode when you make a Core Data based project. Here's that method: 

To perform automatic lightweight migration, you need to have two data models set up, then in code, you tell Core Data to perform the migration. This means that you should not modify your data model until you finish reading this. If you have, (automatically or manually) restore your old model. You'll need it to do the migration. Here's how automatic lightweight migration works: 

The width of a UITabBarItem varies, depending on how many there are. 

iOS apps don't support showing Settings.bundle inside your app, but there's a great library out there called InAppSettingsKit that will allow you to do that. I've used it in some of my apps in the past and I recommend it. 

There's also the Three20 framework, published by Facebook. 

However, if you do not specify a nib name, and do not override the loadView method in your custom subclass, the view controller searches for a nib file using other means. Specifically, it looks for a nib file with an appropriate name (without the .nib extension) and loads that nib file whenever its view is requested. Specifically, it looks (in order) for a nib file with one of the following names: 

Running the older version of the code, I see a pretty much even run at about 1.15 megabytes of memory usage. Everything seems to be allocated and deallocated as necessary. In my new implementation, however, I'm seeing something a little different. Memory usage keeps jumping in little "plateaus", and then eventually seems to peak out at about 1.47 megabytes of usage. Here's what the new Allocations report looks like after running for over 10 hours: 

I've actually ported the KosherJava Library and plan to make it available soon on GitHub! 

I'd be grateful if anyone would help point me in the right direction. 

I'm keeping the rest of this around for historical reference, but the following is not guaranteed to work on recent iOS versions. In fact, it just might not. 

If the view controller class name ends with the word ‘Controller’, as in MyViewController, it looks for a nib file whose name matches the class name without the word ‘Controller’, as in MyView.nib.