Frankly, on the basis of this short clip, it's a little tough to determine precisely what they're doing, but these are the basic building blocks. And in Xcode 9, they've expanded this view debugger so it now includes the relevant view controllers, too: So, there are two parts to that. First, using GCD as an example, you grab a background queue (either grab one of the global background queues, or create your own): If you want to include some annotations in the snapshot, you have to draw them manually (!). This is discussed in some detail at the end of the Putting Map Kit in Perspective video. I have to say that this is one of the least elegant implementations that I've ever seen Apple advise. Anyway, in iOS, it might look like: Having said that, when people suggest that you perform some slow or expensive process asynchronously, they are implicitly suggesting not only that you should run it asynchronously, but that you should do that on a background thread. The goal is to free the main thread so that it can continue to respond to the user interface (rather than freezing), so you are dispatching tasks to a background thread asynchronously. If you really want to develop a custom callout yourself, the Location and Maps Programming Guide outlines the steps involved: BTW, this issue appears to only manifest itself when the SQL contains subselect statements. The easiest approach is to use the existing right and left callout accessories, and put your button in one of those. For example: Clearly, I can just specify an actual font size (in which case I don't see this truncating behavior), but then I'm manually figuring out what size to use. And worse, the font size is the same for landscape and portrait, so right now I'm using a font size that fits in the shorter landscape navigation bar title and the title is smaller than it needs to be in the taller portrait navigation bar. How do we get the label widths to be accurate at this point, so that they reflect their final width? Here's the code that makes it all come together: You can attach this simple sample project to demonstrate the issue. It is based directly on Apple's own sample code. Since all the global dispatch queues are concurrent queues, each block from both of your two tasks will be dequeued and executed simultaneously, provided that GCD determines this is most efficient for the system at runtime (given system load, CPU cores available, number of other threads currently executing, etc). I had an (extensive) conversation with an Apple engineer about this crash. UPDATE 10/22/13: iOS 7.0.3 fixes this issue. I don't want the map screen view controller's nib and views to be loaded and initialized until the user switches to that screen, however. Clearly, with iOS 8 self sizing cells, row height estimation is critically important, so Apple really needs to address this ASAP. It still may be wise to continue shipping any workarounds for a while, until the majority of users on iOS 7 have updated their devices to at least 7.0.3 (which may take a couple weeks). Well, that is assuming your workarounds are safe and tested! Adding a Gesture Programmatically To add a gesture programmatically, you (1) create a gesture recognizer, (2) add it to a view, and (3) make a method that is called when the gesture is recognized. Control drag from the gesture in the Document Outline to your View Controller code in order to make an Outlet and an Action. At the time of this writing I was having trouble adding @IBDesignable to the code, so the views don't show up in IB but they do when you run your app. I could reproduce this in the following simple project: Swift example Updated for Swift 3 This is kind of an old question. I tried a few of the other answers here but couldn't get it to work. Sometimes it is just easier to watch someone do it in action. Here is the video I watched that taught me how to do it: Create a new Tabbed Application project That's it. You should be able to run it now and have all three tabs work. Watch the video that I linked to for more details. Alternatively, you can select the view and then in the menu go to Editor > Arrange > Send to Front. Here is the revised code for our custom view: