If possible, quote some references also, to support your answer. By the way, can I configure Clang (or Visual Studio) so that Visual Studio may use Clang compiler to compile my C and C++ code? We can pass reference of an array to a function like: I tested my symbol lookup API from C++ code. It works fine to resolve the address to a symbol, if given the correct address to start with. In that code, there doesn't seem to be an advantage. But consider the following overloaded functions: But it doesn't say how to get the startinbg function address specific to the application, using ProcessThread.StartAddress. I tried this and it didn't work. I don't exactly understand this. I wrote this code: I know the language specification forbids partial specialization of function template. Is this code really Standard conformant? I know that minimum number of parameters in function definition is zero, but what is the maximum number of parameters in function definition? I am asking the question just for the sake of knowledge and out of curiosity, not that I am going to write a real function. The solution is simple: make the functions const as: Questions I know that its very difficult to debug like this and probably I've not given a lot of informations about the environments and all. But still, my question is: what could be the possible root-cause for this segfault? How to debug further and find that? Once I find the issue, fix would be easy. The difference, however, is at the linking time. Here is what I see, for the case when it works: Given a lambda, is it possible to figure out it's parameter type and return type? If yes, how? I would like to know the rationale why it forbids it? Are they not useful? I know that a temporary cannot be bound to a non-const reference, but it can be bound to const reference. That is,