For me, the above steps solved the issue. As far as I've been able to tell, the error is caused by any combination of: Why am I getting an error "Attribute value must be constant". Isn't null constant??? Can you give a short code sample to make it crystal clear? For example, this code sample just shows where a CompletionService is not needed (=equivalent to ExecutorService) The code looks like this - super simple: It is in fact a bug in hibernate, because it is thrown when persisting objects, while it actually implies a "design time" problem that should be detected when creating the schema. I ended up rolling my own (I took the implementation of Throwable.printStackTrace() and tweaked it a bit): Heh, I discovered/remembered what we are already using for this. Is there a nicer way to write in jUnit Is there a jUnit parallel to NUnit's CollectionAssert? I know there is no direct equivalent in Java itself, but perhaps a third party? Edit - as of Apache Commons 2.1, the correct way to do it is: Executor seems like a clean abstraction. When would you want to use Thread directly rather than rely on the more robust executor? If you project the curves beyond 0.9 on the X-axis, it looks like 1) they will meet at about 1.0 and 2) the meeting point will be at roughly the same Y value as for X = 0.0. In case it is not already obvious: Failing that, does anyone know of a JSON library with a parser and a generator that can be configured to output "pretty" JSON with the attributes in (say) lexical order? (A Java or Ruby library would be ideal, but other leads are also welcome.) The multiply is likely to be faster than the second conditional branch if the hardware-level branch prediction is ineffective. As you increase the ratio ... the branch prediction is becoming less effective. You create and use byte array I/O streams as follows: NB: JAVA_HOME should NOT end with "\bin"1. Peter Lawrey's benchmarking indicates that thread creation is significantly faster these days in absolute terms, but it is unclear how much of this is due improvements in Java and/or the OS ... or faster processor speeds. But his numbers still indicate a 150+ fold improvement if you use a thread pool versus creating/starting a new thread each time. (And he makes the point that this is all relative ...) It is also expensive in the sense that the thread ties down resources as long as it is alive; e.g. the thread stack, any objects reachable from the stack, the JVM thread descriptors, the OS native thread descriptors. If the project strategy is to use Lombok, then the possible helpers will need to get used to it. Per 3.10.5: Pooling of string literals is actually mandated by the standard. All things equal, disabling vectorization will hurt performance in this floating-point case. Whether or not X piece of code is reachable is the same as saying whether the code before it will halt. Binary literals require Java 1.7. So if that's not available, you can go with this: From the docs (emphasis is mine): This page confirms that the HotSpot JVM will do this optimization. The answer is yes. This is called Common Subexpression Elimination and is a standard (and powerful) compiler optimization used in Java, C/C++ and others... If we walk these instructions down one-by-one, we can see how ICC tries to vectorize it: Here's where the 4 sums are recombined: But it turns out that the overhead of vectorization happens to outweigh the benefits of vectorizing. In Java, unreachable code is a compiler error. So in order to maintain compatibility, the language spec defines exactly "how hard" the compiler should try. (Which according to the other answers, is "don't go inside another function".) Remember that mathematically, there are 3 cube-roots. Assuming you want the root that is real, you should do this: But since you disabled vectorization for the x64 version, it obviously becomes slower. Why? It is the equivalent to the Halting Problem. ICC x64 with no vectorization: Now let's look at part of your ICC output: