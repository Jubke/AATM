Here are times when event delegation is required or advantageous: Your code and HTML works just fine here in a jsFiddle as you've shown it. So, it is not an issue with those things exactly as you've shown them. It is more likely something with the environment in your page or dynamic HTML. Some possibilities: The dynamic selector is a selector that matches your dynamic elements. They do not have to exist at the time the event handler is first installed and they can come and go as often as you want. I've so often wondered why jQuery doesn't have a method for this that I've made one myself: Here's an excerpt from the doc: jqXHR.then(function( data, textStatus, jqXHR ) {}, function( jqXHR, textStatus, errorThrown ) {}); Incorporates the functionality of the .done() and .fail() methods, allowing (as of jQuery 1.8) the underlying Promise to be manipulated. Refer to deferred.then() for implementation details. Only use delegated event handling when it actually provides a feature you need or increases performance. Don't just always use it because it's easy because when you don't actually need it. It actually performs worse at event dispatch time than direct event binding. Attach delegated event handlers to the nearest parent to the source of the event as possible. If you are using delegated event handling because you have dynamic elements that you want to capture events for, then select the closest parent that is not itself dynamic. Use easy-to-evaluate selectors for delegated event handlers. If you followed how delegated event handling works, you will understand that a delegated event handler has to be compared to lots of objects lots of times so picking as efficient a selector as possible or adding simple classes to your objects so simpler selectors can be used will increase the performance of delegated event handling. Third off, not all events work or all problems can be solved with delegation. For example, if you want to intercept key events on an input control and block invalid keys from being entered into the input control, you cannot do that with delegated event handling because by the time the event bubbles up to the delegated handler, it has already been processed by the input control and it's too late to influence that behavior. Take a simple function like this: How do you all do it? What am I missing? jqXHR.fail(function( jqXHR, textStatus, errorThrown ) {}); An alternative construct to the error callback option, the .fail() method replaces the deprecated .error() method. Refer to deferred.fail() for implementation details. To understand this a little more, one needs to understand how jQuery delegated event handlers work. When you call something like this: The way to use it for dynamic elements is to use this form: Working example: http://jsfiddle.net/jfriend00/4cAz5/ So, to achieve optimized performance: I should mention that I use Firebug in FF5 and the built-in debugger in Chrome (Chrome more often than Firebug now). And, yes I'm using the debug (non-minified) version of jQuery when debugging. So, this isn't a question about which debugger you use, but how you use the debugger to effectively step through jQuery code. Create Your Own .findNext() Method So, what am I missing here? Is it just a lot less convenient to step through this kind of code? Am I missing some magic techniques built into the jQuery framework to help with this? Or is the price you pay for using this style library that you have to completely change how you debug problems. As people get more and more familiar with promises and as more and more async operations use that concept, I suspect that more and more people will move to the promise API over time, but in the meantime jQuery supports both. FYI, in all three of these options, the HTML is accumulated into an array, then joined together at the end and the inserted into the DOM all at once. This is because DOM operations are usually the slowest part of an operation like this so it's best to minimize the number of separate DOM operations. The results are accumulated into an array because adding items to an array and then joining them at the end is usually faster than adding strings as you go. Because selectors can be fairly involved, this means that jQuery has to parse each selector and then compare it to the characteristics of the original event target to see if it matches each selector. This is not a cheap operation. It's no big deal if there is only one of them, but if you put all your selectors on the document object and there were hundreds of selectors to compare to every single bubbled event, this can seriously start to hobble event handling performance. To swap two divs without losing event handlers or breaking DOM references, you can just move them in the DOM. The key is NOT to change the innerHTML because that recreates new DOM nodes from scratch and all prior event handlers on those DOM objects are lost. I couldn't tell exactly what you were asking with your question, so here are four possibilities. Hopefully one of these matches what you intended to ask or you can slightly modify one of them to fit.