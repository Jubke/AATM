For example, this simple "throb" view animation may well break under autolayout: EDIT 2: In seed 4, we now have access controls! Plus, in one of my apps I have an embedded framework and sure enough, everything was hidden by default and I had to expose all the bits of the public API explicitly. This is a big improvement. But it turns out I don't have to fix it! When I build, I can look into the package of the built app and I see that it has .nib files, not .xib files. The .xib files are not being copied into the resources folder, even though they are in the Copy Files build phase; they are being compiled, even though they are not in the Compile Sources build phase. I would describe Swift's namespacing as aspirational; it's been given a lot of advertising that doesn't correspond to any meaningful reality on the ground. All of this works fine in my actual app; it's just the Quick Look Preview Extension implementation that's having trouble. Is there something special I have to do to open a UIDocument from inside a Quick Look Preview Extension? Apple doesn't provide any sample code; in WWDC 2017 video 229 they just gloss over the whole thing. I updated my target's Architectures build setting from "Standard 32-bit" to Standard (64-bit) and now I'm getting mysterious Xcode linker errors so that I can't build the project successfully. For example: And I can confirm this by looking at the build log: But in renaming my .xib files and adding some new ones, I ended up in a situation where none of my .xib files are listed in the Compile Sources build phase. Instead, they are all listed in the Copy Files build phase. I was not able to fix this. (Don't get me started about that.) I want to test my app when it is not launched via Xcode, but rather by launching directly from the springboard. And I want to see log messages as I do that. The Ground of Being You are going to instantiate UITableViewController by hand (that is, by calling its initializer in code). And you want to subclass UITableViewController because you have instance properties you want to give it. NOTE This bug is fixed in iOS 9, so the entire matter will be moot at that point. The discussion below applies only to the particular system and version of Swift to which it is explicitly geared. The white view is host view; you are supposed to pretend that it is transparent and hence invisible. The red view is its subview, positioned by pinning its center to the host view's center. Now we can scale and rotate the red view around its center without any problem, and indeed the illustration shows that we have done so: Solution 3: Use a Subview The problem with both the above solutions is that we lose the benefits of constraints to position our view. So here's a solution that solves that. Start with an invisible view whose job is solely to act as a host, and use constraints to position it. Inside that, put the real view as a subview. Use constraints to position the subview within the host view, but limit those constraints to constraints that won't fight back when we apply a transform. [Actually, there's a second surprise here: applying a transform to a view triggers layout immediately. This seems to me be another bug. Or perhaps it's the heart of the first bug. What I would expect is to be able to get away with a transform at least until layout time, e.g. the device is rotated - just as I can get away with a frame animation until layout time. But in fact layout time is immediate, which seems just wrong.] Now I want to do this on my device. I can see my connected device listed in the Console app: You could be justified in opening a radar for this. The fact that a typedef is not treated the same as a specified type is surprising at least, even if documented. So which is better depends on what problem you're solving. Be sure to read over Apple's Migrating Away from Threads for more info. EDIT: Noting @lnafziger's comment from the ObjC Programming Language, there is definitely either an error in the ARC spec/implementation or an error in the linked document, so one of them should be fixed. Any compiler operation which incidentally strips type “sugar” from a type will yield a type without the attribute, which may result in unexpected behavior. See Jeff LaMarche's quick note on how to do this. It's documented in the same page you're reading, but Jeff's explanation is clearer. Synchronized access in Cocoa is best achieved with GCD queues. For example, this is a common approach that achieves a reader/writer lock (concurrent reading, exclusive writing). As charles notes, in Swift 3 this is built in: The problem is that your property definition does not conform to the definition of a retainable object pointer (emphasis added): Did you create a typedef as specified? No you did not. OK, so how would we do this? I will here provide a meta-answer: In that case you can create one and pass it into clang, but it's incredibly rare that it's a good idea.