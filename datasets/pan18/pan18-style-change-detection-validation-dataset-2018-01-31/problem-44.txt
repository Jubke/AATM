Go with one of the agile processes. Scrum is the most popular one. Work closely with your stakeholders. Show them working code every few weeks and get their feedback. Working together you can make it a success. How do you determine which product to push and which one not? In general, you will push those products that give you the most contribution margin. If you do that though, you may be up against some bottlenecks also known as "constraints" in accounting jargon! For example, in a job shop that I worked for earlier, our vertical boring machine was the constraint. It was the most expensive, required the most skill and could also be the most profitable. So, you want to maximise the contribution margin from such a constrained resource. You have to figure out which is the constrained resource in your shop. Once you do, here is a good article that shows you how to model that. Moving from waterfall to agile. Following the Scrum (or a modified Scrum) process. Congratulations! You are on the right track. It is possible to work out the other steps from here. After you have booked the orders, as @CodeGnome pointed out, you apply Kanban to continually improve your processes. This is a failed approach. In software development, there are two inherent limitations to trying to arrive at a good estimate from a fixed scope: Refactoring - why and when "Refactoring is risky. It requires changes to working code that can introduce subtle bugs. Refactoring, if not done properly, can set you back days, even weeks. And refactoring becomes riskier when practiced informally or ad hoc." - from a Foreword by Erich Gamma to Refactoring: Improving the Design of Existing Code by Martin Fowler et al. TL;DR To the very best of my knowledge, there is no canonical formula for determining Work in Progress (WIP) limits. However, there are some empirical best-practices. There is value in a smooth flow and a predictable cadence. When the process is disrupted, the cost to the organization should be made visible on the card wall and through reported metrics. Since Kanban is based on agreements, part of that agreement needs to be an acceptance of responsibility by management for the natural consequences of disrupting the process. TL;DR The Scrum Guide was designed to be a structured, portable framework that could be lightly customized for each implementation. The Kanban Method is closer to a set of principles, and doesn't even mandate a set of common artifacts—not even the uniquitious board and cards that many people consider synonymous with Kanban! — CodeGnome's Iron Law of Process Economics Rule 2: The client is responsible for timely performance of their responsibilities, which include providing feedback and user acceptance testing within agreed-upon time-frames. A healthy Kanban is done in full awareness of this truth. A dysfunctional organization typically ignores it. Perfection is not required; only a desire for kaizen. Three Simple Rules for Preserving Your Sanity Rule 1: The client doesn't get to dictate your internal processes. This should be made clear by the client/vendor relationship, your contract, and the collaboration process you hammer out jointly. In fact, in Extreme Programming the customer should always be available to the team. Further, they are expected to actively collaborate with the development team, as illustrated by this direct quote: Fixed, cross-functional teams that work on different projects, but only one at a time. Product-based teams, where the teams are formed around each product. Note that each product will have its own separate Product Backlog, and each team will work from exactly one Product Backlog. Feature-based teams, where teams are formed around features (rather than projects), who may either share a single Product Backlog or have one backlog per feature team. How you delineate projects, products, and features can complicate this, but the distinction between a single product with many features and multiple products should be your guiding principle. A great deal depends on correctly conceptualizing the project, and not being afraid to split off related projects when they no longer fit within the bounds of a single product or team. Perhaps counter-intuitively, reducing the WIP limits below the team's maximum capacity will generally improve your throughput. This is most often because at 100% capacity, any roadblocks or unexpected issues can create bottlenecks that impact the entire pull-queue cycle. Ensuring that there is sufficient slack in the process enables the team to overcome minor process issues as they arise without needed to "stop the line" altogether. This ability to adapt without stopping the line every time is part of what makes a process agile. Additional clarifications based on good points made by @DavidEspina: Refactoring - why and when "Refactoring is risky. It requires changes to working code that can introduce subtle bugs. Refactoring, if not done properly, can set you back days, even weeks. And refactoring becomes riskier when practiced informally or ad hoc." - from a Foreword by Erich Gamma to Refactoring: Improving the Design of Existing Code by Martin Fowler et al. Moving from waterfall to agile. Following the Scrum (or a modified Scrum) process. Congratulations! You are on the right track. It is possible to work out the other steps from here. Arms length contracts fail: I am not saying that you don't estimate/plan at all. I am saying that you cannot do arms length contracts on the lines of: "You give me the scope, I will give you a firm estimate. You approve it. I go away and build the software and come back to deliver it when ready." That model is known to fail big time for software. Go with one of the agile processes. Scrum is the most popular one. Work closely with your stakeholders. Show them working code every few weeks and get their feedback. Working together you can make it a success.