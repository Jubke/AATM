From the C99 standard (7.21.1/2): It's a historical oddity, still common practice among teams who like to blindly apply coding standards that they don't understand. Yes: you can use the type system to catch errors like adding a mass to a distance at compile time, without adding any runtime overhead. It's a style. I'm no judge of style, but if you like to keep maintainence programmers on their toes, it certainly does that. Personally, I like my code to be readable, but that's just me. Local variables (pedantically, variables with block scope) are only accessible within the block of code in which they are declared: There are two separate concepts here: Combining these two behaviours gives the bizarre code you posted. Automatic variables (pedantically, variables with automatic storage duration) are local variables whose lifetime ends when execution leaves their scope, and are recreated when the scope is reentered. For built-in types, you'd be correct: the built-in assignment operator requires a modifiable lvalue on the left hand side. The second (useless) form was easier to describe and enforce, so it was blindly adopted by many, many teams; decades later, you still see it used, and even advocated, from time to time. The magic number is supposed to be 32 random bits, where each is equally likely to be 0 or 1, and with no simple correlation between the bits. A common way to find a string of such bits is to use the binary expansion of an irrational number; in this case, that number is the reciprocal of the golden ratio: "c" was the tag for type "char", so it couldn't also be used for "const"; so "k" was chosen, since that's the first letter of "konstant" in German, and is widely used for constants in mathematics. The syntax specification in 6.4/1 gives the following for the condition: However, this is not using the built-in operator, but the overload that's implicitly declared by the class. This is a member function, equivalent to If you don't feel like defining the types and operators yourself, Boost has a Units library for that. Some time later, as typed languages (particularly C) became more popular, some idiots heard that this was a good idea, but didn't understand its purpose. They proposed adding redundant tags to each variable, to indicate its declared type. The only use for them is to make it easier to check the type of a variable; unless someone has changed the type and forgotten to update the tag, in which case they are actively harmful. Your second and third examples are neither valid expressions, nor valid declarations, since a declaration can't form part of an expression. While it would be useful to be able to write code like your third example, it would require a significant change to the language syntax. Absolutely. The standard Chrono library already does this for time points and durations. So the answer is no; the check is not necessary (or yes; you can pass zero). Long ago, most commercial programming languages were weakly typed; automatic type checking, which we take for granted now, was still mostly an academic topic. This meant that is was easy to write code with category errors; it would compile and run, but go wrong in ways that were hard to diagnose. To reduce these errors, a chap called Simonyi suggested that you begin each variable name with a tag to indicate its (conceptual) type, making it easier to spot when they were misused. Since he was Hungarian, the practise became known as "Hungarian notation". The reason is that an unchecked access can probably be done with a single processor instruction. A checked access will also have to load the size from memory, compare it with the index, and (assuming it's in range) skip over a conditional branch to the error handler. There may be more faffing around to handle the possibility of throwing an exception. This will be many times slower, and this is precisely why you have both options.