Note that because P ≡ Q is equivalent to (P ⊃ Q) & (Q ⊃ P), it is possible to summarize P ≡ Q as saying that "P is a necessary and sufficient condition for Q", where the 'necessity' comes from the conditional Q ⊃ P, and the 'sufficiency' comes from P ⊃ Q. as being the collection of all of the ordinals up to ω, and then gotten from ω again by increments. Then we may define 2ω+1, 2ω+2, and so forth up to 3ω; and so forth ad infinitum. We then get another limit ordinal, "Any X" statements are universal statements. You have to be careful to think about how the word 'any' is used. We often ask in English: are there any of [some object]? This question might be one about existential quantification, but it certainly is not an existential proposition — nor a proposition of any kind. We may consider all possible values of each atomic proposition, and compute the corresponding truth-values of the formulae that arise as a result. Then we may restrict to those rows of the truth-table in which the assumed propositions take the value 'true'. If any atomic proposition obtains a constant value across all of those rows, we may infer that it is correspondingly either 'true' or 'false'. "All X" and "every X" statements are universal statements. This is again true whether or not we're talking about some X having a property, or some X lacking a property, and as in the case of "some" statements, it's right there in the language: an "all" statement will boil down to something of the form ∃x∀y [Dx & (Dy ⇒ y=x)] — premise ∀y [Dd & (Dy ⇒ y=d)] — by exemplar Dd & (Da ⇒ a=d) — universal instantiation Dd & (Db ⇒ b=d) — universal instantiation again Dd — conjunctive elimination ∃x (Dx) — existential introduction Da ⇒ a=d — conjunctive elimination Db ⇒ b=d — conjunctive elimination again (Da & Db) ⇒ (a=b) — modus ponens/conditional introduction/conjunctive introduction/transitivity of equality/etc. ∀x∀y[(Dx & Dy) ⇒ x=y] — universal generalization ∃x (Dx) & ∀x∀y[(Dx & Dy) ⇒ x=y] — conjunctive introduction (iv) ⇒ (i) How to begin looking.    In order to consider logics in which A ⇒ ~A can be false when ~A is true, there are some things at minimum which you must look for: it must be a logic in which or "I am Elvis Presley, and anyone who is Elvis Presley is none other than myself". If I wanted to say that there is one and only one Elvis Presley, without claiming that I am myself Elvis, I could write instead What this really means is that consistency is a bit of a chimeral property of a formal system to have. We are denied even the conceit of self-verifiability in totalizing formal systems. You can of course prove that a formal system S is consistent in another formal system M — but then why should you accept that M is consistent? Proving it so in another system M' is just pushing the problem away a further step. The consequence is that consistency of a formal system is a fundamentally negative property: a failure to be able to exhibit a contradiction, in which case you can never be sure if it is really consistent, or if you just haven't realized how to produce a contradiction in the system. 2 := {0,1} = {∅,{∅}} = 1 ∪ {1}; Suppose the predictor actually has the described power, and you both believe it does and trust that it will provide the $1M if you intend to take the contents of only the one box. Then, if only for selfish reasons, you'd be a fool to plan to take the second box. And after the reveal, it doesn't matter that you could then grab the second box as well: by hypothesis, you are in that circumstance because of a prediction, assumed accurate, that you won't choose to. Connection between ∃ and 'OR' In the same way as ∀ expresses something like an 'AND' across all objects being considered, ∃ expresses something like an 'OR'. Suppose the domain of discourse is people in some specific room (which I will refer to as 'this' room; you can imagine the speaker being in the room themselves), and M(x) = "x is a murderer". Then An alternative way of considering P ⊃ Q is as a "constraint" that someone claims holds for the state of affairs. That constraint is either satisfied (in which case P ⊃ Q is true) or it is violated (in which case P ⊃ Q is false). This picture is somewhat different from the usual way that we think of "if-then" statements, which is more like causation than constraint. For this reason, it might be helpful to describe P ⊃ Q as either