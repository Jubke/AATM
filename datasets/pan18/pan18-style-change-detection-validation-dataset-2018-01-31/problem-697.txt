If you are programming Python using Emacs, then you should probably be using python-mode. With python-mode, after marking the block of code, You could use cursor.lastrowid (see "Optional DB API Extensions"): What accounts for this difference? I'm trying to time some code. First I used a timing decorator: Some R datasets can be loaded into a Pandas DataFrame or Panel quite easily: If you want to print the help message only if no arguments are supplied on the command line, then perhaps this is still the easiest way: For example, after marking a rectangular region, Should either method be believed? This answer comes from Steven Bethard on Google groups. I'm reposting it here to make it easier for people without a Google account to access. Also useful are the rectangle commands that operate on rectangles of text instead of lines of text. So the question is: How can I modify the code to track the data coordinates with respect to both axes? Here is a list of what can be pickled. In particular, functions are only picklable if they are defined at the top-level of a module. I'm about to embark on some large Python-based App Engine projects, and I think I should check with Stack Overflow's "wisdom of crowds" before committing to a unit-testing strategy. I have an existing unit-testing framework (based on unittest with custom runners and extensions) that I want to use, so anything "heavy-weight"/"intrusive" such as nose, webtest, or gaeunit doesn't seem appropriate. The crucial unit tests in my worldview are extremely lightweight and fast ones, ones that run in an extremely short time, so I can keep running them over and over all the time without breaking my development rhythm (e.g., for a different project, I get 97% or so coverage for a 20K-lines project with several dozens of super-fast tests that take 5-7 seconds, elapsed time, for a typical run, overall -- that's what I consider a decent suite of small, fast unit-tests). I'll have richer/heavier tests as well of course, all the way to integration tests with selenium or windmill, that's not what I'm asking about;-) -- my focus in this question (and in most of my development endeavors;-) is on the small, lightweight unit-tests that lightly and super-rapidly cover my code, not on the deeper ones. The classical implementation, CPython, is often called just "Python" for short -- but it's just one of several production-quality implementations, side by side with Microsoft's IronPython (which compiles to CLR codes, i.e., ".NET"), Jython (which compiles to JVM codes), PyPy (which is written in Python itself and can compile to a huge variety of "back-end" forms including "just-in-time" generated machine language). They're all Python (=="implementations of the Python language") just like many superficially different book objects can all be Bibles (=="copies of The Bible"). So, before diving in and spending a day or two of precious development time "rolling my own" simulations of GAE subsystems for unit testing purposes, I thought I'd double check with the SO crowd and see what y'all think of this... or, if there's already some existing open source set of such simulators that I can simply reuse (or minimally tweak!-), and which I've just failed to spot in my searching!-) Edit: "why not GAEUnit" -- GAEUnit is nice for its own use cases, but running dev_appserver and seeing results in my browser (or even via urllib.urlopen) is definitely not what I'm after -- I want to use a fully automated setup, suitable for running within an existing test-running framework which is based on extending unittest, and no HTTP in the way (said framework defines a "fast" test as one that among other thing does no sockets and minimal disk I/O -- we simulate or mock these -- so via gaeunit I could do no better than "medium" tests) + no convenient way to prepopulate datastore for each test (and no OO structure to help customize things). I have a list of variable names, like this: I often find myself using the % operator to strings with a dictionary of names and values to interpolate. Often the names in the string is just the names of local variables. So (with the answer below) I can do something like this: The following code worked for me: A friend was "burned" when starting to learn Python, and now sees the language as perhaps fatally flawed. Has anyone succeeded in doing this? Update, responding to the question (in a comment) of why I'd want to do this: How do I convert this to a dictionary where the keys are the variable names (as strings) and the values are the values of the variables? At my previous employer I had wanted to spend some time playing with building embedded systems in tinypy, which is a "minimalist implementation of Python in 64k of code". (But I never got to it and I no longer have time.) I know it should be possible from this chart. But unfortunately the documentation of M2Crypto I've found is sketchy. (The homepage at http://chandlerproject.org/ seems to be gone, along with Chandler.) He was using a library and changed the value of an object's attribute (the class being in the library), but he used the wrong abbreviation for the attribute name. It took him "forever" to figure out what was wrong. His objection to Python is thus that it allows one to accidentally add attributes to an object.