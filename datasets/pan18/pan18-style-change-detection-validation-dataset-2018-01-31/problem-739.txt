For any standards efforts that are being discussed, is there any support coming or available in any of the browsers for it? 

An operative part for this question is step #5 above. I'm using the Flash-based ZeroClipboard now to solve this problem (as is bitly too), but would like to get rid of Flash in my pages for a variety of reasons (mobile, performance, security, standards, viewer hassle). Since ZeroClipboard requires that it is initiated with an actual mouse click by the user, it seems like it has proven to be relatively safe (aside from the general Flash vulnerabilities). There are three AJAX calls that must happen in consecutive order (the output of one is used as part of the input of the next). 

Also, are there ways in the language to control whether something is passed by reference or by value? Here's one example from that article: 

I'm not aware of any particular convention for javascript files as they aren't really unique on the web versus css files or html files or any other type of file like that. There are some "safe" things you can do that make it less likely you will accidentally run into a cross platform issue: 

The native code networking that lies under the ajax call will know when the ajax response is done and an event will get added to the javascript event queue. How the native code knows when the ajax call is done depends upon the implementation. It may be implemented with threads or it may also be event driven itself (it doesn't really matter). The point of the implementation is that when the ajax response is done, some native code will know it's done and put an event into the JS queue. Unfortunately, the promise version only results in a zero length file. Here's the code for the promise version: I'm trying to use async file IO and bluebird promises in node.js to write some data to a local file. I've successfully written a synchronous version of this function and an async version using callbacks. But, because the callback version was nested hell and had all sorts of error handling problems and was not very easy to maintain, I thought I'd try a version using promises instead since this should be its forte (better error handling, less nesting, easier to sequence async operations). To understand this a little more, one needs to understand how jQuery delegated event handlers work. When you call something like this: In the ECMAScript grammar specification for Javascript, there are blocks defined with a double colon like this: 

If the element is not now the first element in the list of scripts that will execute in order as soon as possible to which it was added above, then mark the element as ready but abort these steps without executing the script yet. Variable arguments - You can pass different sets of arguments (in both type and quantity) and the function will behave in a way that matches the arguments passed to it. If by "restart", you mean to start a new 4 second interval at this moment, then you must stop and restart the timer. If the element has a src attribute The element must be added to the set of scripts that will execute as soon as possible of the Document of the script element at the time the prepare a script algorithm started. 

I've been using code like this for inheriting from another object: Default values for function arguments In ES6, Javascript adds built-in language support for default values for arguments. Async scripts (regardless of how they are specified as async) load and run in an unpredictable order. The browser loads them in parallel and it is free to run them in whatever order it wants. 

I need to be able to detect whether there are scrollbars (both vertical and horizontal) on a browser window. I've been using this code but it isn't working reliably in Firefox 5. 

I have several pages that users come to in order to get stuff that they want on their clipboard so they can paste it elsewhere (snippets of JS or CSS). It's obviously easier for the end-user if they don't have to manually select the correct piece of text and then manually copy it to the clipboard. 

The relevant part of the language grammar from section A.3 of the ES5 ECMAScript spec is this: