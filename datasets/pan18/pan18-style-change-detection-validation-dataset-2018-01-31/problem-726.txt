Now, on to the question at hand. The system frameworks use a design where any exception is considered to be a fatal, non-recoverable, error; a programmer error, for all intents and purposes. There are a very limited number of exceptions (heh) to this rule. In reality, there is little use in making this strong of a distinction between the two save for that fixing either requires very different strategies. As Amit indicated, Heapshot Analysis is quite adept at finding both leaks, abandoned memory and -- quite important -- overall "Undesirable Memory Growth". Abandoned Memory Allocations that are in the app's live object graph but are no longer reachable due to application logic issues are considered abandoned, but not leaked. Fixing abandoned memory can be considerably trickier for a couple of reasons. With this in mind, a leak and abandoned memory actually do have two distinct meanings. Secondly, there might be non-zeroing non-retained weak references to the abandoned allocation. That is, if you figure out where to prune the strong references and make the allocation actually go away, that doesn't mean that your work is done; if there are any remaining non-zeroing weak references, they will now be dangling pointers and..... BOOM. Something bizarre is going on, then. Coincidentally, I've been using blocks-as-values in an ARC based application in the last week and it is working fine. Leak A leak is a piece of memory for which there are no references to the allocation from any live object in the application's live object graph. Note that if object A points to object B and object B points to A, but nothing in the live object graph points to either A or B, it is still a leak. If the B->A and A->B references are both retained references, you got yourself a retain cycle & a leak. First, no need to jump through such hoops to print a hex value, just do: Update2: Added a 10 queue version of each kind of test. Wow. OK -- My original performance assessment was flat out wrong. Color me stupid. I.e. the memory is unreachable and, thus, there is no way that it can ever be referred to again (barring bugs). It is dead memory. Not so stupid. My performance test was wrong. Fixed. Along with a deep dive into the GCD code. When designing concurrent systems, it is best to keep the boundary between queues as small as possible. A big part of that is ensuring that as few resources as possible "live" on both sides of a boundary. Update: Code for the benchmark can be found here: https://github.com/bbum/StackOverflow Hopefully, it is correct now. :) The compiler doesn't automate blocks-as-parameters for a few reasons: The return value behavior could be automated because it is always correct to return a heap based block (and always an error to return a stack based block). In the case of a block-as-an-argument, it is impossible to automate the behavior in a way that would be both very efficient and always correct. The issue, in the context of "real world paying project" use, is that you are effectively creating a relatively generic bridge that will then have to have specific bridges at either end to interface with either typical C++ libraries or typical Objective-C APIs/libraries. To put it another way, you have effectively created a new runtime derived from an amalgamation of two existing runtimes. Yes -- by using @property and @synthesized getters/setters, you guarantee that: The same goes for the stack; any object referred to by any thread's live stack is, itself, considered live. â€¢ There are only so many hours in the day and automating the handling of parameters is rife with non-obvious edge cases. If this were handled automatically in the future, it could be done without breaking existing code and, thus, maybe it will be done in the future. (well, that turned into more of a book than intended... hopefully still useful!) Do not use exceptions to indicate anything but unrecoverable errors It is only appropriate to use @try/@catch to deal with unrecoverable errors. It is never appropriate to use @throw/@try/@catch to do control-flow like operations on iOS or Mac OS X. Even then, consider carefully whether you are better off using an exception to indicate an unrecoverable error or simply crashing (call abort()); a crash often leaves behind significantly more evidence. That may come as a surprise. The reality, though, is that design patterns that require checking for mutability are confusing to use and incur significant overhead. And, as you point out in the Cons, you pretty much have to touch, wrap, modify and/or debug a shim on top of every C++ class you want to bring into this pattern. (For those with access) Filed rdar://10355515 asking for clarification. It is a really nice bit of code; I particularly like the use of imp_implementationWithBlock() (but I admit I might be partial to that particular feature of the runtime ;). And, of course, explorations like this are always an incredibly valuable learning tool.