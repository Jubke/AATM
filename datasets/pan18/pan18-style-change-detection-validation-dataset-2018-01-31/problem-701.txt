This post has been rewritten as an article here. Here is my go at it (no loops and handles both SI units and binary units): You'll have to do the following: Source: Java: Removing duplicate white spaces in strings A better workaround: You can write your own utility class with a static method instead: This is explained in detail in the Java Language Specification, ยง 9.2 Interface Members. References to the JLS are appreciated. Furthermore, it is easy for a compiler/JVM to detect "unread locals". In the program below for instance, Eclipse notices that "The local variable t is never read". First of all, there are two types of initialization blocks: TL;DR: What "stack depth complexity" is considered reasonable? Logarithmic complexity, recursive binary search for instance, O(log N) is surely ok, but how about O(N), O(N log N), O(N2)? Where would you typically draw the line?(2) This post has been rewritten as an article here. No, they don't. And there is no common "root" interface implicitly inherited by all interfaces either (as in the case with classes) for that matter.(*) The method is kept in the API for backward compatibility for an unspecified period of time, and may in future releases be removed. That is, no, it's not wrong, but there is a better way of doing it, which is more robust against API changes. (1) I realize that such languages sometimes supports things like @tailrec, but this question concerns Java, C# etc. (2) Note that I'm not concerned about CPU overhead etc. Just the stack depth. That is, a shutdown hook keeps the JVM running until the hook has terminated (returned from the run()-method. Most likely no. It will continue to work as before the deprecation. The contract of the API method will not change. If some internal data structure changes in favor of a new, better method, there could be a performance impact, but it's quite unlikely. The example at http://www.java2s.com gives you some code examples. The following code produces the image below: From the definition of deprecated: This post has been rewritten as an article here: Java: Why wait must be called in a synchronized block ... Eclipse reports the following error: Without going into details: This synchronization issue is universal. As Michael Borgwardt points out, wait/notify is all about communication between threads, so you'll always end up with a race condition similar to the one described above. This is why the "only wait inside synchronized" rule is enforced. A paragraph from the link posted by @Willie summarizes it quite well: In your case it would look something like: The can part: (*) Java itself doesn't support macros. On the other hand, you could pipe the source code through the C pre processor (CPP for short) just like the C/C++ compile chain does. Worrying about stack overflows I tend to avoid recursive solutions if the maximum stack depth is linearly proportional to the size of the input (or worse). I realize however that in many other languages (even ones targeting the JVM such as Scala and Clojure) many algorithms, such as basic list algorithms for instance, are often expressed recursively where the maximum stack depths is proportional to the length of the list.(1) So, are my worries about stack overflows in linear-stack-depth-algorithms justified? That's pretty much exactly what I want - but that doesn't go earlier than 1970 either in most cases, nor does it include all the relevant data: Sometimes Java generics just doesn't let you do what you want to, and you need to effectively tell the compiler that what you're doing really will be legal at execution time. Is there a way to persuade ICU4J to fall back to tz abbreviations? In my very specific case, that's all I'm looking for. I usually find this a pain when I'm mocking a generic interface, but there are other examples too. It's usually worth trying to work out a way of avoiding the warning rather than suppressing it (the Java Generics FAQ helps here) but sometimes even if it is possible, it bends the code out of shape so much that suppressing the warning is neater. Always add an explanatory comment in that case! (EDIT: Like other answerers, I'd definitely prefer to put the inner loop in a different method. This answer just shows how the requirements in the question can be met.) The output format I'm targeting includes the abbreviation in effect for a particular time - such as "BST" for "British Summer Time", or "PST" for "Pacific Standard Time". Note that the class name has to be a fully-qualified one, i.e. including the namespace. For nested classes, you need to use a dollar (as that's what the compiler uses). For example: It violates encapsulation. You shouldn't be able to bypass the parent class's behaviour. It makes sense to sometimes be able to bypass your own class's behaviour (particularly from within the same method) but not your parent's. For example, suppose we have a base "collection of items", a subclass representing "a collection of red items" and a subclass of that representing "a collection of big red items". It makes sense to have: Rather than keeping everything string-based, you should use a class which is designed to represent a file system path. It's not clear to me whether ICU4J is getting its abbreviations from the tz data or from CLDR - I suspect it's the latter, given that there's nothing in the tz data to suggest a difference here.