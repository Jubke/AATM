The destruction is a bit more delicate. global variables are destroyed in the reverse order in which they were created. So in the local static case, you don't actually control things.... Unfortunately, Wikipedia's implementation does not deal with positional arguments: the kind that allows you to specify print the 3rd parameter there, etc... It would be easy, if only we had a function with this prototype: C++ templates are generally assimilated to creators of bloat, and the Shim idea deals with exactly that: making the template just a thin wrapper over a regular function. It's a really great way to cut down on the bloat. I suspect it's got something to do with the linker resolving the templates methods... Even before delving into assembly, there are code transformations that exist at a higher level. First, let me give an example: You simply need to understand what a generator does: I've just been beaten (rather hardly) on the head by some non-trivial warning from Visual Studio 2010 (C++). For example, in C++, the original Standard was published in 1998, so we talk about C++98, and when we refer to its first correction, published in 2003, we talk about C++03. Note: this leads to the use of private inheritance for Policy Design in order to have EBO kick in when appropriate The main issue about singletons is the lifetime management. Note: according to NoSenseEtAl, Andrei Alexandrescu seems to question this "quicker". I personally measured a speed-up in my programs and I have yet to see a proof about the loss of optimizability. I would claim it does not. A program should be written with readability in mind, not performance (at least, no as first criterion). Exceptions are to be used when one expects that the caller cannot or will not wish to handle the failure on the spot, and pass it up the stack. Bonus: in C++11 exceptions can be marshalled between threads using the Standard Library. There are situations when you may wish to roll your own smart manager. Do check that you did not just missed some feature in the libraries your are using beforehand. The compilation gave the following output: In your trivial example, it's easy enough. Conceptually: My project is very simply organized: I was wondering if, using the as-if rule, one could still be able to perform this optimization. Apparently it seems that the standard forbids this optimization on data members, that is even if a data member is empty, it must still take at least one byte worth of place: from n3225, [class] Steve Jessop seems to be of an opinion that it is so that no two sub-objects would have the same address. I thought about it, however it doesn't actually prevent the optimization in most cases: To illustrate with an example, suppose that we have such grammar (in a customized BNF format): For example, here is a "Quick & Dirty" trick to obtain the number of characters (which is useful to know if it will fit in your display box): edit: following a number of answers and comments, and to make it clearer what I am wondering about. The second happens much more often: smart manager means ownership. You may use pointers to point at existing resources without managing their lifetime, for example: In C++03, we have copy elision to prevent this: Free-functions allow for more generic programming because they can be added afterwards, on a data-structure you cannot alter. The Empty Base Optimization is one such trick: in some conditions, if the base class is empty (does not have any non-static data member), then the compiler may elide its memory representation. My folder hierarchy looks like so: Note: C++0x is the next standard, so avoid listing C++0x extensions, since they'll be standard soon I'll take the opportunity to expose the not-Phoenix implementation :) I would like to extract information from a body of text and be able to query it. So I was thinking about the set of overload operators we should write not to eliminate temporaries, but to limit the cost of their construction (stealing resources). I think it's more a question of philosophy than technic :) Search no more: Visual has neatly flatten my folder hierarchy, and therefore is unable to neatly compile the source. From @Matteo Italia: Visual Studio Compliance Page This sounds relatively easy, except that I have two big constraints: Anyway, this is, I think, the optimized C version. Already it is much simpler. Based on this, here is my crack at ASM (I let Clang generate it, I am useless at it): So now that we have an example that may (or not) be legal, the more general question at hand for all of us standardistas is whether changing the dynamic type of an object is ever allowed. We already know that the C++ compiler may reuse storage (fortunately), so it's a bit tricky.