edit: It is imperative that the method produces a Fortran-ordered matrix directly (due to the size of the data, I can't afford to create a C-ordered matrix and then transform it into a separate Fortran-ordered copy.) For the avoidance of doubt, the result is 1000 x 1000. This is implementation-specific, but your interpreter is probably interning compile-time constants but not the results of run-time expressions. As to your general question about constructors, Wikipedia is a good starting point: link. For Python-specific stuff, I highly recommend the Python tutorial. Is it? Are there any potential side effects of doing so? The best way to rewrite the code depends on what it is you're trying to do. You could copy every element that does match the condition into a second list: How do I go about figuring out what this is exactly? In Python 2.7, I define an empty new-style class: In what follows I use CPython 2.7.3. There is no function overloading in Python, meaning that you can't have multiple functions with the same name but different arguments. In Python 2.2 (don't ask), what's the neatest way to sort a list and remove duplicates? Assigning to a slice requires an iterable on the right-hand side. If you eliminate the effect of constant folding, there's little to separate multiplication and division: You are correct in that your list contains a reference to the original dictionary. If you know for a fact that the string contains an underscore, you can even unpack the LHS and RHS into separate variables: I have a list of variable names, like this: Update, responding to the question (in a comment) of why I'd want to do this: A friend was "burned" when starting to learn Python, and now sees the language as perhaps fatally flawed. At my previous employer I had wanted to spend some time playing with building embedded systems in tinypy, which is a "minimalist implementation of Python in 64k of code". (But I never got to it and I no longer have time.) Has anyone succeeded in doing this? The following code worked for me: Update: I changed the title, since it didn't occur to me that M2Crypto would be a pre-build Ubuntu package. Unit tests don't provide a solution to this. One doesn't write unit tests against an API being used. One may have a mock for the class, but the mock could have the same typo or incorrect assumption about the attribute name. He was using a library and changed the value of an object's attribute (the class being in the library), but he used the wrong abbreviation for the attribute name. It took him "forever" to figure out what was wrong. His objection to Python is thus that it allows one to accidentally add attributes to an object. I know it should be possible from this chart. But unfortunately the documentation of M2Crypto I've found is sketchy. (The homepage at http://chandlerproject.org/ seems to be gone, along with Chandler.) The only thing I've been able to tell my friend is that after several years of writing Python code full-time, I don't recall ever being burned by this. What else can I tell him? How do I convert this to a dictionary where the keys are the variable names (as strings) and the values are the values of the variables? I have a working test of a hardware device that uses RSA encryption, in Python using M2Crypto. Now I need to test a similar device that uses 3DES encryption. But I can't figure out how to use M2Crypto to do triple DES encryption. As to your general question about constructors, Wikipedia is a good starting point: link. For Python-specific stuff, I highly recommend the Python tutorial. In what follows I use CPython 2.7.3. If you eliminate the effect of constant folding, there's little to separate multiplication and division: If we examine the bytecodes, we'll see that they are exactly the same: In Python 2.2 (don't ask), what's the neatest way to sort a list and remove duplicates? Assigning to a slice requires an iterable on the right-hand side. In Python 2.7, I define an empty new-style class: There is no function overloading in Python, meaning that you can't have multiple functions with the same name but different arguments. How do I go about figuring out what this is exactly? edit: The list is short, so efficiency is not a concern. Also, the elements are immutable. Sometimes, they're different. To give an example that came up recently: You are correct in that your list contains a reference to the original dictionary. Any suggestions for speeding this up? Is it? Are there any potential side effects of doing so? For the avoidance of doubt, the result is 1000 x 1000. On Python 2.6.5, the following code: If you run the following, you'll see for yourself: A friend was "burned" when starting to learn Python, and now sees the language as perhaps fatally flawed. Update, responding to the question (in a comment) of why I'd want to do this: He was using a library and changed the value of an object's attribute (the class being in the library), but he used the wrong abbreviation for the attribute name. It took him "forever" to figure out what was wrong. His objection to Python is thus that it allows one to accidentally add attributes to an object. Update: I changed the title, since it didn't occur to me that M2Crypto would be a pre-build Ubuntu package. I know it should be possible from this chart. But unfortunately the documentation of M2Crypto I've found is sketchy. (The homepage at http://chandlerproject.org/ seems to be gone, along with Chandler.) How do I convert this to a dictionary where the keys are the variable names (as strings) and the values are the values of the variables?