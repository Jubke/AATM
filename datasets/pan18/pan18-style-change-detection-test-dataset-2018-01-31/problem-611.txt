Also, I see a lot of similarly-related questions to this, but couldn't find an exact match that asked this same question. If you see that it is indeed a dupe of another question, please point it out to me and I will close this question myself (please don't just closevote it!). 

This is because, in terms of being a "class" (category) of numbers, prime numbers have the least amount of factors. According to that article, funnels occur when a given key is a factor or multiple of the size of the table. So if we set the table size to 100 (not a prime number), we introduce the possibility of funneling when the provided key is any factor of 100: 1, 2, 4, 5, 10, ..., 100, 200, 300, etc. Think of a funnel as an actual funnel: multiple inputs get funneled into the same place. 

After looking each of these up online/on Wikipedia, I was able to get (for the most part) decent definitions for each of these. What I am not understanding is how all of these technologies/concepts work together on the backend to provide a 2nd/business tier solution. Short answer: A funnel occurs when 2+ keys get hashed to the same value because of an error with the underlying hashing function. Like this: 

But if we make the size of the table to a prime, say, 101... then the only possibility of a funnel occurs at: 1, 101, 202, 302, etc. We've greatly reduced the possibility of a funnel. Configuring JPA Make a practice project and follow this tutorial verbatim. But what happens when a request isn't supposed to return any content to the client-side? Can I have: 

Can someone please give an example of an architecture that would use all of these technologies/concepts, and explain what role each of them play in the overall solution? Once I see a working example I'm sure it will help me connect most of the dots. I am a Java developer who is beginning to grasp the full power of dependency injections, and it suddenly dawned on me that there's no way to inject a static method. So it got me thinking: are static methods DI anti-patterns? I believe (someone else can correct me) you would need the same bridge pattern if you wanted to have multiple Spring controller implementations: