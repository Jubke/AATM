Its version 4.4.9, which apparently contains the DOMDocument class, so that was not a reliable test. It may not fully support DOMDocument, but it passes the if(class_exists('DOMDocument')) test nonetheless. 

This site is on a shared server hosting package. Characters {}|&~![()" must not be used anywhere in the key and have a special meaning in the value. 

For example, my body tag code is... 

Syntax error, unexpected "!", etc... I have a client who's wordpress sites have gotten hacked twice by iframe scammers. Each time they've injected iframe code into the content of the sites. The code below is working nearly flawlessly, however my value for page title on one of my pages keeps coming up empty after a few page refreshes... It sticks for awhile, then it appears to reset to empty. I'm thinking I must have a conflict in the code below, but I can't quite figure it. I'd like to place a directive in my theme's functions.php file which appends a classname to the wordpress body tag. Is there a built-in API method for this? When I run a phrase that contains double quotes through this function, its replacing the quotes with quot. 

How should I filter the $file before passing it to parse_ini_file() to deal with these characters to that they are preserved when passed to the update_option() call? 

For example, given this content as the test-backup.ini file... This last time, today, they simply changed the siteurl in wp_options to their iframe code. The result was obvious and appeared to simply botch the paths of the scripts that rely on 

The only active plugins on the site are contact form 7 and google xml sitemaps. Any recommendations welcome :) The function below takes the "test-backup.ini" file, parses it and inputs the values into the DB via the update_option() method. 

Once Server B receives the zip file, it should extract the contents and copy the files into a specific folder on server B overwriting any existing files. What are your thoughts? Any way to scan a site for potential SQL injection vulnerabilities? I want to completely remove them (also single quotes). How can I alter the function to do that? EDIT : There are (at least) two ways of running PHP, when working with Apache : Instead, with your array that looks like this : 

For instance, if you have this function : If you want it passed by reference, you'll have to modify the function, this way : For the second part of your question, see the array page of the manual, which states (quoting) : 

Don't hesitate to read the References Explained section of the manual : it should answer some of your questions ;-) The first one will, for instance, get you an array like this one (quoting the manual) : 

Just beware the notice : you might want/need to use the @ operator. 

Wouldn't it be a lot easier if your array was declared like this : EDIT after @Jhonny's comment : So, let's try this portion of code : 

(see the manual page of the first one to find out why the "and/or" ;-) ) This means you will need to look into output buffering if you wish to use this code as is. What's an effective way to handle data validation, say, from a form submission? You have to set cookies before any headers are sent out. 

The issue that has arisen is related to serializing objects. The objects being serialized, and other objects not being serialized, are being converted to strings thus breaking the code. This code worked before the server was hacked. Does anyone know of a tip, trick, or obscure documentation that will allow me to either give these fields a border or some other means of determining their exact size and position? 

I have begun outlining how I expect the API to work (and starting documenting it as well) and I want to make sure I get it right, or as close to right, as I can from the beginning as I know once you have declared a public API you want to avoid changing that API at all costs. 

I have created a website which allows users to sign up for, and use, an online service. To help promote the website we will be have re-sellers who will be offering their own branded services through us. The initial plan is to allow re-sellers to place registration, login, and lost password forms on their own website and use an API created by us to handle these requests.