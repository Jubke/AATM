Be sure to read over Apple's Migrating Away from Threads for more info. As charles notes, in Swift 3 this is built in: Did you create a typedef as specified? No you did not. OK, so how would we do this? You could be justified in opening a radar for this. The fact that a typedef is not treated the same as a specified type is surprising at least, even if documented. You have no way to prove at compile-time that there is only one possible result on an array. What you're actually asking for is the first matching result. The easiest (though not the fastest) is to just take the first element of the result of filter: See Jeff LaMarche's quick note on how to do this. It's documented in the same page you're reading, but Jeff's explanation is clearer. I will here provide a meta-answer: The "barrier" in "dispatch_barrier_async" means that it is the only thing allowed to run on the queue at that time, so all previous reads will have completed, and all future reads will be prevented until it completes. This scheme means that you can have as many concurrent readers as you want without starving writers (since writers will always be serviced), and writes are never blocking. On reads are blocking, and only if there is actual contention. In the normal, uncontested case, this is extremely very fast. In that case you can create one and pass it into clang, but it's incredibly rare that it's a good idea. EDIT: Noting @lnafziger's comment from the ObjC Programming Language, there is definitely either an error in the ARC spec/implementation or an error in the linked document, so one of them should be fixed. If you want to do a different two-finger gesture, get the two dots the distance apart that you want them to be, then hold down the shift key, while still holding down the option key. That will lock the position of the two finger presses together so you can do, for example, a two-finger swipe. Any compiler operation which incidentally strips type “sugar” from a type will yield a type without the attribute, which may result in unexpected behavior. EDIT: To your specific question about a HUD you use in all your view controllers, yes, you should absolutely import it into every view controller that actually uses it. This makes the dependencies clear. When you reuse your view controller in a new project (which is common if you build your controllers well), you will immediately know what it requires. This is especially important for categories, which can make code very hard to reuse if they're implicit. So which is better depends on what problem you're solving. The problem is that your property definition does not conform to the definition of a retainable object pointer (emphasis added): EDIT2 (Mar 2013) FYI for those interested in this technique, ARC documentation for clang includes the following note: (assuming you're using ARC, otherwise you need to release the copy'd dictionaries) No. Apps can only modify files within the documents directory, within their own sandbox. This is for security, and ease of installing/uninstalling. So you could only do this on a jailbroken device. Now there is a sheet of clear plastic with a word on it, this sheet of plastic stays stationary no matter what (the position:fixed elements). So when you move the magnifying glass the fixed element appears to move. So in iOS the viewport moves, in a traditional browser the webpage moves. In both cases the fixed elements stay still in reality; although on iOS the fixed elements appear to move. The way to get around this, is to follow the last few paragraphs in this article Fixed positioning doesn't work on iOS like it does on computers. You have done the right thing by balancing the init with a release. The simplest way to do this is to loop through a mutable copy of the dictionary and if the value is null set the value to the value you want.