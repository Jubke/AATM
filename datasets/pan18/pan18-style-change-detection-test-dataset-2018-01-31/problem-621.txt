Step 3: Materializing We still need some way to say "OK, I 'm done composing; get me the results". It is perfectly possible to use a dedicated method for this purpose: Custom projections In some scenarios you may need to sort by a column whose values do not lend well to sorting. The "birthday" column in the sample data set fits this description: it does not make sense to compare birthdays as strings (because e.g. "01/01/1980" comes before "10/10/1970"). In this case we want to specify how to project the actual data to a form that can be compared directly with the desired semantics. Running the timing test on my dev server to see it in action, I got: Finally, here is an example that uses all the features: it first sorts by number descending, then by birthday ascending: The algorithm below can be proved to work (barring bugs) by induction: Step 1: Kicking off We established that there needs to be at least one type that collects information about the query plan. Let's assume the type looks like this: TL;DR: Theoretically you can't count on it; for practical purposes IMO you can. Specifically, advantages of this solution include: Update: To clarify, what I 'm looking for is something that would allow me to write code morally equivalent to this: Following this practice religiously will "automatically" take care of other things for you as well: PHP has no facility that enables a method to be "automatically" called, so there has to be something that triggers the materialization, even if that something does not look like a method call at first sight. But what? Well, think about what is perhaps the most common use case: Reverse sort To sort by name descending: Pretty intuitive, don't you agree? Here's a solution I wouldn't be ashamed to show. Let's sort the example data set without a projection and see what happens: The most practical approach is simply to cast the object you are interested in back into an array, which will allow you to access the properties: That's because theoretically the developers could have chosen to reserve themselves the option of changing the implementation at a future date so that it does not honor the existing order any more (perhaps to improve performance, or to gain some other benefit). You also had a PHP syntax error: you split the query up into two strings. https://github.com/philip/MySQLConverterTool https://github.com/dshafik/php7-mysql-shim I'm using a Mac, so I use BrowserStack to test IE, which limits my debugging ability at the client end. Does anyone know what could be causing this, and if there's something we can do to work around it? I reproduced the problem with BrowserStack's screenshots feature: http://www.browserstack.com/screenshots/3659c3b992a1738594d2fd370caef2852fecb3fa See http://dev.mysql.com/doc/refman/5.5/en/insert-on-duplicate.html We have one customer (that I know of so far) where this isn't working consistently, but only in IE 8 and older. The URL with the problem is: On our adserver, we use the following simple PHP script to redirect to the landing page of the ad: I performed a packet capture on our webserver, it looks like we're sending the correct header: There's also a MySQL Shim Library located here: http://webutil.bridgebase.com/v2/ad_lp.php?id=340&lp=http%3A%2F%2Ftravelinsingles.com%2Fhome.htm You can download a converter tool from here: This should redirect to http://travelinsingles.com/home.htm, but sometimes it goes to http://webutil.bridgebase.com/home.htm (which doesn't exist). It always seems to happen on the first click on the ad; sometimes subsequent clicks follow the redirect correctly, sometimes they continue to go to the bad URL. Suppose we're sending trivial feedback and going to make these fields dynamic: 3 simple rules for you to get it right: So, the question is: is mysql[i]_real escape_string() totally unacceptable? Or is it's still possible to use this function to create your own kind of prepared statements? Everyone who wants to be a PHP programmer, always takes only the first word and completely ignores the second. Same for your question. Imagine you'll ever get some difference. Even big one, say, one method is 2 times faster. Oh my, 2 times! I choose it and optimized my app well, it will run 50% faster now! I can fairly understand what casting is required if two operands has different types. But why it does "usual math" when both are strings? There are no "illegal" characters for the database. Database that cannot store some characters is a nonsense. There are some service characters, like quotes, used to delimit strings. These characters should be just escaped, not eliminated. First of all, always have this line before mysqli connect in all your environments: So, to make a valid url from a free-form text Yes, you can. But First argument should be an array. I am hesitated to ask this question because it looks weird. But anyway. Just in case someone had encountered the same problem already... filesystem functions (fopem, file, file_get_contents) behave very strange for http:// wrapper To send a query to the database, you have 2 options: would be this PHP code enough to protect us from all kinds of mail-injections? Performance issues are quite hard to understand. It is advised for the newbies not to take it into account. Because they are always impressed with trifle things and fail to see a real important things. Just because lack of experience. When PHP came to the scene, everyone were impressed with main differences from Perl: But, of course, I don't want to parse any placeholder-like combinations, that occasionally may occur inside of quoted literals - either single quoted or double quoted or backtick-quoted.