I found a Google Groups thread in which the author solves a similar problem by using lipo to manually combine different builds of the library. I'd really like to avoid that step if possible -- this seems like something that I should be able to accomplish with the right combination of build settings in the two projects. 

Remember, we're talking about a megapixel image here, not a 32 x 32 px tiny icon. When you're dealing with teensy icons, you do have to hand tweak each pixel to get the best approximation of the image you're trying to represent. When you're talking about scaling from 1024 px square to 360 px square, there shouldn't be a problem unless you've added some very fine detail at the large size. Don't do that. 

This at least lets me build the project for iOS devices and debug, so that's a very good start. I'm not sure what we lose by leaving out dsym, so I'm going to keep looking. If you're using a predicate to search for a match, use string comparison operators (LIKE, CONTAINS, etc.) with the case-insensitive option: @"SELF like[c] %@". You may also want the diacritic-insensitive option: @"SELF like[cd] %@". The code given above reports the size of the screen, even in split screen mode. When you use split screen mode, your app's window changes. If the code above doesn't give you the information you expect, then like the OP, you're looking at the wrong object. In this case, though, you should look at the window instead of the screen, like this: 

One great way to debug code that deals with app states that are difficult to recreate is to write unit tests. In a test, you can create any state you want. You can even create app states that may be impossible to recreate in your app. And you can debug that code over and over again. Like the previous solution, it takes a little more time to write the code up front, but you'll save so much time on each iteration of your debug cycle that its well worth it. Even better, you can add the test to your build process so to help ensure that the functionality doesn't break later. Same way you'd instantiate a UIView from code normally: 

In Xcode, hold down the Option key and choose Product->Run... (the ellipses are added when you hold Option down). This will bring up the scheme editor, with the Run scheme selected. Click on the Info tab, and on the resulting Info panel you'll see a radio group labelled "Launch" with two options: "Automatically" and "Wait for MyApp.app to launch". If you select the second option, Xcode will start the debugger and wait for you to launch your application manually. You can set a breakpoint at the beginning of the code you want to debug, and the debugger will stop there. Use the regular old POSIX file system API. (Best for existing Unix code, or code that you also want to compile on other platforms.) When people talk about container views, they usually mean just a plain old UIView that contains other views. Using a view in that way lets you move all the views it contains as a group, so that their positions relative to each other are maintained. It also makes it easy to hide all the contained views as a group. 

There are a few things to consider: 

For what it's worth, this is exactly how PhoneGap works on iOS. PhoneGap includes an NSURLProtocol subclass called PGURLProtocol that looks at the scheme of any URL the app tries to load and takes over if it's one of the schemes that it recognizes. PhoneGap's open-source cousin is Cordova -- you may find it helpful to take a look. Here's a shorter, safer way to do what you're doing above: The key to getting two bezier curves to join smoothly is that the relevant control points and the start/end points on the curves must be collinear. Think of the control point and the endpoint as forming a line that's tangent to the curve at the endpoint. If one curve starts at the same point where another ends, and if they both have the same tangent line at that point, the curve will be smooth. Here's a bit of code to illustrate: 

Is there any way to get the actual data that will be sent when a NSURLConnection sends a NSURLRequest? Right now I'm mainly interested in looking at HTTP and HTTPS requests, but since NSURLRequest works for many protocols, it seems like there ought to be a general way to see the corresponding data for any type of request. Update: Apple DTS suggests reinstalling Xcode. I haven't been able to try that yet, but will update this answer if it's helpful. Update: In response to nielsbot's question, I took a closer look at the VM Tracker's info and found that the largest part of the memory that I'm not seeing in Allocations is attributed to Core Animation: 

How can I get the iOS 7 behavior in iOS 8? Alternatively, how can I adjust the web view content size?