Friendship is NOT inherited Also John's children are a bunch of hooligans so I don't trust them either they are definitely not my friends nor are my own children who I trust as far as I could throw them. I was surprised at the performance of the "Multi" Threaded version. So I doubled the size of the thread pool version to see what happened. Note: I know that modern servers use an event driven model with non-blocking sockets to achieve much better performance and I am working in the direction but I want to get the base line data numbers first. It is the responsibility of the owner of a chunk of dynamically allocated memory to release that memory. So the question really becomes who owns the memory. Edit: Apparently also in "More Effective C++" Item 11: Prevent exceptions from leaving destructors The full source of this code is available here. Usage: ====== When object can have multiple owers with a lifetime that can not be determined at compile time. Does anybody have any knowledge about the standards requirements for thread re-use and what I should expect the re-use behavior to be? 1) There is no way to annotate a class with type information that is accessable at runtime. 2) Parsing the source to generate stuff is way to complex. The problem here is in your interpretation of the article you link. All the other stuff that Java/C# have in their standard libraries. The stuff that makes it simpler for a beginner to jump in and say Wow done and it works everywhere (nearly). Anyway. Here hoping there are some cool projects out there. Looking at Java and C# they manage to do some wicked processing based on special languaged based anotation (forgive me if that is the incorrect name). You are always your own best friend. This allows things like copy constructors where you can access the private member of another object even though there is no real accesses. But I was thinking that this could be done with some template meta-programming to achieve the same basic affect as anotations (still just thinking about it). Like char_traits that are specialised for the different types an xml_traits template could be used in a declaritive way. This traits class could be used to define how a class is serialised/deserialized by specializing the traits for the class you are trying to serialize. Maybe there is not one. But if there are a couple that could be bundled together as a starting point (and potentially modified over time (where is that deprecated keyword)) into a nice consolidated whole.