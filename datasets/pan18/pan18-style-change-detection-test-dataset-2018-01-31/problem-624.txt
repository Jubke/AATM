This is the group who are using alpha-numeric characters that are probably not randomly generated. Something like a bible quote or such. These phrases have approximately 2.3 bits of entropy per character. And when I say built on top of, I mean from the ground up based on the framework. I don't mean referencing the framework as a series of libraries. I mean basing the entire architecture of the application off of the framework (which then ties you into the framework). Basically, after you hash the password, feed the entire hash output into a strong encryption algorithm. Then store the encrypted result. Let's take an example. Let's take a quote from the bible (just because it's a common source of long text, not for any other reason): Back To The Real World These kinds of entropy calculations don't really matter much in the real world. What matters is guessing entropy. That's what directly effects what attackers can do. That's what you want to maximize. So, to simulate it, I've been thinking about generating a random number for each place (about 150,000 random numbers). But, I also want to keep to the spirit of the data, and keep the distribution relatively the same (or at least reasonably close). I've been racking my brain all day trying to think of a way to do it, and have come up empty. They way you're doing it is fine. There are a few other things that can make your life easier that you can do as well. I'm thinking that he real distribution should be hyperbolic in the first quadrant... I'm just blanking on how to turn a linear, even distribution of random numbers into a hyperbolic distribution (If hyperbolic is even what I want in the first place). It's by no means simple. There are at least 2 main interfaces (I think there are 4, but that's another topic). It needs to be both highly configurable and highly customizable. I would expect between 50 and 200 installs per year, so ease of maintenance is a major concern. So, to sum, here's the distribution I would like (approximately): That's my $0.02 at least (or possibly way more than $0.02)... But I'm looking for the antithesis... Focus on securing the rest of the site. And add a password entropy meter to the password box on registration to indicate password strength (and indicate if a password is overlong that the user may wish to change it)... Then it increments the argument. I really fear we are going down the wrong path. The Underlying Point If you're using references, you're doing it wrong about 99% of the time. So don't use references unless you absolutely need them. PHP is a lot smarter than you may think at memory optimizations. And your use of references really hinders how it can work. So while you think you may be writing smart code, you're really going to be writing less efficient and less friendly code the vast majority of the time... A little while ago I read a great article which described a number of reasons against using any of the RAD frameworks available for PHP. Basically, it argued that a good framework should get you off the ground quickly, and then should get out of your way. But none of the PHP frameworks did that. It pointed out that Django was good at doing just that (but that's obviously not a PHP framework). So the end result is this table of worst-case runtime: For this group, you are going to slightly unlock more entropy (not create it, but allow more entropy to fit into the bcrypt password). When I say slightly, I mean slightly. The break-even occurs when you max out the 512 bits that SHA512 has. Therefore, the peak is at 78 characters. I'm also not really talking about rapid prototyping where the code will likely be re-written anyway. I'm more looking at long-term applications that have a specific business requirement to meet, and must be supported and maintained (and modified) for a relatively long period of time. These are your users using password generators which generate what amount to large keys for passwords. They are random (generated, not human chosen), and have high entropy per character. These types are using high-bytes (characters > 127) and some control characters. However, the rest of the team wants to pick a framework (they want to use YII) first and skip the high level architecture completely. Their argument is that the framework did the high level architecture first and let's you "just start coding". Let me say that again. For users who are using high entropy, long passwords, your solution significantly reduces the strength of their password by a measurable amount. (62 bits of entropy lost for a 72 character password, and more for longer passwords) One thought I had was to square the random number (between 0 and sqrt(70)). But that would favor both less than 1 and larger numbers. Here's a nice simple recursive function (Based on zero indexed numbers, meaning 0 == A, 1 == B, etc)... Now, an SQL-Injection attack will not leak anything useful, because they don't have the cipher key. And if the key is leaked, the attackers are no better off than if you used a plain hash (which is provable, something with the pepper "pre-hash" doesn't provide).